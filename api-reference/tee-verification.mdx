---
title: "TEE Verification"
description: "Guide to verifying TEE attestation reports and signatures for TEE-backed models."
---

## Overview

NanoGPT supports private TEE-backed models. Use these endpoints to verify enclave attestation and signatures for chat completions.

### Fetch Attestation Report

```bash
curl "https://nano-gpt.com/api/v1/tee/attestation?model=TEE/hermes-3-llama-3.1-70b" \
  -H "Authorization: Bearer $API_KEY"
```

### Fetch ECDSA Signature

```bash
curl "https://nano-gpt.com/api/v1/tee/signature/{requestId}?model=TEE/hermes-3-llama-3.1-70b&signing_algo=ecdsa" \
  -H "Authorization: Bearer $API_KEY"
```

## Python Example

Save the following as `test_tee.py` and run:

```bash
python3 test_tee.py --api-key YOUR_API_KEY --base-url https://nano-gpt.com --model TEE/hermes-3-llama-3.1-70b
```

```python

"""
#!/usr/bin/env python3
"""
TEE Attestation & Signature Verification Example for NanoGPT.

Usage:
    python3 test_tee.py --api-key YOUR_API_KEY --base-url https://nano-gpt.com --model TEE/hermes-3-llama-3.1-70b
"""
import requests
import json
import hashlib
from cryptography import x509
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend
import base64
from eth_keys import keys  # import for Ethereum ECDSA recovery
from eth_utils import keccak  # import for Ethereum message hashing

# Hardcoded configuration - set your values here
API_KEY = "INSERT_API_KEY"
BASE_URL = "https://nano-gpt.com/api"
MODEL = "TEE/hermes-3-llama-3.1-70b"

def fetch_attestation(base_url, api_key, model):
    url = f"{base_url}/v1/tee/attestation"
    headers = {"Authorization": f"Bearer {api_key}"}
    params = {"model": model}
    resp = requests.get(url, headers=headers, params=params)
    print("=== Attestation Report ===")
    print(f"Status: {resp.status_code}")
    try:
        data = resp.json()
        print(json.dumps(data, indent=2))
    except ValueError:
        print(resp.text)
        data = None
    return data


def chat_completion(base_url, api_key, model, stream=False):
    url = f"{base_url}/v1/chat/completions"
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }
    payload = {
        "model": model,
        "stream": stream,
        "messages": [
            {"role": "system", "content": "You are a helpful assistant."},
            {"role": "user",   "content": "What is your model name?"}
        ]
    }
    if stream:
        resp = requests.post(url, headers=headers, json=payload, stream=True)
        print("=== Streaming Chat Completion ===")
        request_id = None
        for line in resp.iter_lines(decode_unicode=True):
            if line.startswith("data: "):
                data_str = line[len("data: "):]
                if data_str == "[DONE]":
                    print("[DONE]")
                    break
                chunk = json.loads(data_str)
                print(json.dumps(chunk, indent=2))
                if not request_id and "id" in chunk:
                    request_id = chunk["id"]
        return request_id
    else:
        payload_str = json.dumps(payload, separators=(",", ":"), ensure_ascii=False)
        req_hash = hashlib.sha256(payload_str.encode("utf-8")).hexdigest()
        resp = requests.post(url, headers=headers, json=payload)
        resp_text = resp.text
        resp_hash = hashlib.sha256(resp_text.encode("utf-8")).hexdigest()
        print("=== Chat Completion ===")
        print("Request Payload Hash:", req_hash)
        print(resp_text)
        print("Response Body Hash:", resp_hash)
        result = json.loads(resp_text)
        return {"id": result.get("id"), "request_hash": req_hash, "response_hash": resp_hash}


def fetch_signature(base_url, api_key, model, request_id, algo="ecdsa"):
    url = f"{base_url}/v1/tee/signature/{request_id}"
    headers = {"Authorization": f"Bearer {api_key}"}
    params = {"model": model, "signing_algo": algo}
    resp = requests.get(url, headers=headers, params=params)
    print("=== Signature ===")
    print(f"Status: {resp.status_code}")
    try:
        data = resp.json()
        print(json.dumps(data, indent=2))
    except ValueError:
        print(resp.text)
        data = None
    return data


def verify_signature(signing_address, message, signature_hex):
    print("=== Verifying Signature ===")
    try:
        # decode raw signature hex (r||s||v)
        sig_hex = signature_hex[2:] if signature_hex.lower().startswith("0x") else signature_hex
        sig_bytes = bytes.fromhex(sig_hex)
        # prepare Ethereum prefixed message hash (personal_sign)
        message_bytes = message.encode("utf-8")
        prefix = f"\x19Ethereum Signed Message:\n{len(message_bytes)}".encode("utf-8")
        message_hash = keccak(prefix + message_bytes)
        # parse r, s, v and normalize v
        r = int.from_bytes(sig_bytes[:32], byteorder="big")
        s = int.from_bytes(sig_bytes[32:64], byteorder="big")
        v = sig_bytes[64]
        # Ethereum v is 27 or 28; convert to 0 or 1
        if v >= 27:
            v -= 27
        sig = keys.Signature(vrs=(v, r, s))
        pub_key = sig.recover_public_key_from_msg_hash(message_hash)
        recovered_address = pub_key.to_checksum_address()
        # compare recovered address to expected
        if recovered_address.lower() == signing_address.lower():
            print("Signature verification succeeded.")
        else:
            print(f"Signature verification failed: expected address {signing_address}, got {recovered_address}")
    except Exception as e:
        print("Signature verification failed:", e)


def main():
    # will hold cryptography public key object for verification
    pub_key_obj = None
    attestation = fetch_attestation(BASE_URL, API_KEY, MODEL)
    # Extract raw EC public key from certificate in the attestation report
    public_key = None
    if attestation and "nvidia_payload" in attestation:
        try:
            # parse nvidia_payload JSON string if needed
            payload = attestation["nvidia_payload"]
            if isinstance(payload, str):
                payload = json.loads(payload)
            # certificate is base64-encoded PEM; decode to get actual PEM bytes
            cert_b64 = payload["evidence_list"][0]["certificate"]
            pem_data = base64.b64decode(cert_b64)
            cert_obj = x509.load_pem_x509_certificate(pem_data, default_backend())
            # get cryptography public key object
            pub_key_obj = cert_obj.public_key()
            # serialize for debugging if needed
            public_key = pub_key_obj.public_bytes(
                encoding=serialization.Encoding.X962,
                format=serialization.PublicFormat.UncompressedPoint
            ).hex()
        except Exception as e:
            print("Failed to extract public key from certificate:", e)
            public_key = None
    # Non-streaming chat and signature verification
    chat_data = chat_completion(BASE_URL, API_KEY, MODEL, stream=False)
    if chat_data and isinstance(chat_data, dict) and "id" in chat_data:
        request_id = chat_data["id"]
        signature_data = fetch_signature(BASE_URL, API_KEY, MODEL, request_id)
        if signature_data and "text" in signature_data and "signature" in signature_data and "signing_address" in signature_data:
            signing_address = signature_data["signing_address"]
            message = signature_data["text"]
            signature = signature_data["signature"]
            verify_signature(signing_address, message, signature)
    # Streaming chat and signature verification (no local hashing)
    stream_id = chat_completion(BASE_URL, API_KEY, MODEL, stream=True)
    if stream_id:
        signature_data = fetch_signature(BASE_URL, API_KEY, MODEL, stream_id)
        if signature_data and "text" in signature_data and "signature" in signature_data and "signing_address" in signature_data:
            signing_address = signature_data["signing_address"]
            message = signature_data["text"]
            signature = signature_data["signature"]
            verify_signature(signing_address, message, signature)


if __name__ == "__main__":
    main()