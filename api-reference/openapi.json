{
  "openapi": "3.1.0",
  "info": {
    "title": "NanoGPT API",
    "description": "API documentation for the NanoGPT language, image, video, speech-to-text, and text-to-speech generation services",
    "license": {
      "name": "MIT"
    },
    "version": "1.0.0"
  },
  "servers": [
    {
      "url": "https://nano-gpt.com/api",
      "description": "NanoGPT API Server"
    }
  ],
  "paths": {
    "/v1/chat/completions": {
      "post": {
        "description": "Creates a chat completion for the provided messages",
        "security": [
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "X-Provider",
            "in": "header",
            "description": "Optional provider override for pay-as-you-go requests on supported open-source models (case-insensitive). Subscription requests ignore this header.",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "Parameters for chat completion",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Chat completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatCompletionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Unexpected error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/completions": {
      "post": {
        "description": "Creates a completion for the provided prompt",
        "security": [
          {
            "bearerAuth": []
          }
        ],
        "requestBody": {
          "description": "Parameters for text completion",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CompletionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Text completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CompletionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Unexpected error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/talk-to-gpt": {
      "post": {
        "description": "Legacy endpoint for chat interactions with the GPT model",
        "security": [
          {
            "apiKeyAuth": []
          }
        ],
        "requestBody": {
          "description": "Parameters for talking to GPT",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TalkToGptRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Talk to GPT response",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "description": "Text response followed by metadata in <NanoGPT> tags"
                }
              }
            }
          },
          "400": {
            "description": "Unexpected error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/models": {
      "get": {
        "description": "List available models with optional detailed information including pricing",
        "security": [
          {
            "bearerAuth": []
          },
          {
            "apiKeyAuth": []
          }
        ],
        "parameters": [
          {
            "name": "detailed",
            "in": "query",
            "description": "Returns detailed model information including pricing",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of available models",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Unexpected error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/models": {
      "get": {
        "description": "Legacy endpoint to list available models",
        "security": [
          {
            "apiKeyAuth": []
          }
        ],
        "responses": {
          "200": {
            "description": "List of available models (legacy format)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelsLegacyResponse"
                }
              }
            }
          },
          "400": {
            "description": "Unexpected error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/models/{canonicalId}/providers": {
      "get": {
        "description": "List available providers and pricing for a model that supports provider selection",
        "security": [
          {
            "bearerAuth": []
          },
          {
            "apiKeyAuth": []
          }
        ],
        "parameters": [
          {
            "name": "canonicalId",
            "in": "path",
            "description": "Canonical model ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Provider availability and pricing for the model",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelProvidersResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request - Invalid model ID",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/check-balance": {
      "post": {
        "description": "Check the account balance",
        "security": [
          {
            "apiKeyAuth": []
          }
        ],
        "responses": {
          "200": {
            "description": "Account balance information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BalanceResponse"
                }
              }
            }
          },
          "400": {
            "description": "Unexpected error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/invitations/create": {
      "post": {
        "description": "Create an invitation or referral link with an optional credit amount.",
        "security": [
          {
            "bearerAuth": []
          },
          {
            "apiKeyAuth": []
          }
        ],
        "requestBody": {
          "description": "Invitation creation parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InvitationCreateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Invitation created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InvitationCreateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request - Invalid request body, invalid amount, or insufficient balance",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid session or unable to get session",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Failed to create invitation",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/user/provider-preferences": {
      "get": {
        "description": "Fetch saved provider preferences for the current user session",
        "security": [
          {
            "bearerAuth": []
          },
          {
            "apiKeyAuth": []
          }
        ],
        "responses": {
          "200": {
            "description": "Provider preference settings",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProviderPreferencesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Unexpected error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "patch": {
        "description": "Update provider preferences for the current user session",
        "security": [
          {
            "bearerAuth": []
          },
          {
            "apiKeyAuth": []
          }
        ],
        "requestBody": {
          "description": "Provider preference updates",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ProviderPreferencesUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Updated provider preference settings",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProviderPreferencesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request - Invalid exclusions or no usable providers",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity - Invalid payload",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Clear saved provider preferences for the current user session",
        "security": [
          {
            "bearerAuth": []
          },
          {
            "apiKeyAuth": []
          }
        ],
        "responses": {
          "204": {
            "description": "Provider preferences cleared"
          },
          "400": {
            "description": "Unexpected error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/check-midjourney-status": {
      "post": {
        "description": "Check the status of an asynchronous Midjourney image generation task",
        "security": [
          {
            "apiKeyAuth": []
          }
        ],
        "requestBody": {
          "description": "Task ID to check status for",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CheckMidjourneyStatusRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Midjourney task status response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CheckMidjourneyStatusResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request (e.g., missing task_id)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized (invalid API key)"
          }
        }
      }
    },
    "/receive-nano": {
      "post": {
        "description": "Process pending Nano transactions for the account",
        "security": [
          {
            "apiKeyAuth": []
          }
        ],
        "responses": {
          "200": {
            "description": "Nano receive operation result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReceiveNanoResponse"
                }
              }
            }
          },
          "400": {
            "description": "Unexpected error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/nsfw/image": {
      "post": {
        "description": "Binary NSFW classification for image URLs or data URLs",
        "security": [
          {
            "apiKeyAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "requestBody": {
          "description": "NSFW image classification request",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NsfwImageRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "NSFW classification response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NsfwImageResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request - Invalid image URLs, JSON parsing error, or policy violation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid session or API key"
          },
          "429": {
            "description": "Too Many Requests - Rate limit exceeded",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - NSFW classification failed"
          }
        }
      }
    },
    "/generate-video": {
      "post": {
        "description": "Generate videos using supported text-to-video, image-to-video, and video-to-video models. The response includes a runId and pending status; poll the status endpoint for completion. See the docs for the current model list and required inputs.",
        "security": [
          {
            "apiKeyAuth": []
          }
        ],
        "requestBody": {
          "description": "Parameters for video generation across different models and providers",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VideoGenerationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Video generation request submitted successfully (asynchronous processing)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VideoGenerationResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request - Invalid parameters or safety filter triggered",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing API key"
          },
          "500": {
            "description": "Server Error - Video generation failed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/generate-video/status": {
      "get": {
        "description": "Poll the status of a video generation request submitted via /generate-video. Returns normalized status and the final video URL on completion.",
        "security": [
          {
            "apiKeyAuth": []
          }
        ],
        "parameters": [
      {
        "name": "runId",
        "in": "query",
        "description": "Run ID returned from the POST /generate-video response",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      {
        "name": "model",
        "in": "query",
        "description": "Model identifier used in the generation request (e.g., 'veo2-video')",
        "required": false,
        "schema": {
          "type": "string"
        }
      }
        ],
        "responses": {
          "200": {
            "description": "Current status for the requested video generation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenerateVideoStatusResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request - Missing or invalid parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Request not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/generate-video/recover": {
      "get": {
        "description": "Recover recent video generation runs for a user.",
        "security": [
          {
            "apiKeyAuth": []
          }
        ],
        "parameters": [
          {
            "name": "model",
            "in": "query",
            "description": "Optional model filter",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Max results (default 10, max 50)",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 50
            }
          },
          {
            "name": "conversationUUID",
            "in": "query",
            "description": "Filter by conversation",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Recovered runs",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true
                }
              }
            }
          },
          "400": {
            "description": "Bad Request - Invalid parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing API key"
          },
          "500": {
            "description": "Server Error - Failed to recover runs",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/generate-video/extend": {
      "post": {
        "description": "Extend a Midjourney video using a task-based flow (taskId + index).",
        "security": [
          {
            "apiKeyAuth": []
          }
        ],
        "requestBody": {
          "description": "Midjourney extension request payload (taskId from the original run + index).",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VideoExtendRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Video extension request submitted successfully (asynchronous processing)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VideoGenerationResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request - Invalid parameters or safety filter triggered",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing API key"
          },
          "500": {
            "description": "Server Error - Video extension failed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/generate-video/content": {
      "get": {
        "description": "Proxy content retrieval for Sora 2 videos.",
        "security": [
          {
            "apiKeyAuth": []
          }
        ],
        "parameters": [
          {
            "name": "runId",
            "in": "query",
            "description": "Run ID returned from the POST /generate-video response",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "model",
            "in": "query",
            "description": "Must be sora-2",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "variant",
            "in": "query",
            "description": "video, thumbnail, or spritesheet",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Content response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true
                }
              }
            }
          },
          "400": {
            "description": "Bad Request - Missing or invalid parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing API key"
          },
          "500": {
            "description": "Server Error - Failed to retrieve content",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/video/status": {
      "get": {
        "description": "Check the status of a video generation request",
        "security": [
          {
            "apiKeyAuth": []
          }
        ],
        "parameters": [
          {
            "name": "runId",
            "in": "query",
            "description": "Run ID from the generation request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "projectId",
            "in": "query",
            "description": "Project ID from the generation request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "cost",
            "in": "query",
            "description": "Cost of the video generation",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "paymentSource",
            "in": "query",
            "description": "Payment source used",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Video generation status",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VideoStatusResponse"
                }
              }
            }
          },
          "400": {
            "description": "Unexpected error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/video/status": {
      "get": {
        "description": "Unified video status endpoint that works with any provider. Check the status of a video generation request using only the request ID - the system automatically determines the provider and returns normalized status information.",
        "security": [
          {
            "apiKeyAuth": []
          }
        ],
        "parameters": [
          {
            "name": "requestId",
            "in": "query",
            "description": "The unique request ID returned from any video generation endpoint",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "fal-1234567890"
          }
        ],
        "responses": {
          "200": {
            "description": "Unified video generation status",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnifiedVideoStatusResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request - Missing requestId parameter",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Video generation request not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "Server Error - Failed to check video generation status",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/images/generations": {
      "servers": [
        {
          "url": "https://nano-gpt.com",
          "description": "Root server for OpenAI-compatible endpoints"
        }
      ],
      "post": {
        "description": "Creates an image generation for the provided prompt (OpenAI-compatible)",
        "security": [
          { "bearerAuth": [] }
        ],
        "requestBody": {
          "description": "Parameters for image generation",
          "required": true,
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/OpenAIImageGenerationsRequest" }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Image generation response. Each data[i] contains either { url } or { b64_json }. When requesting response_format: \"url\", the API may fall back to returning { b64_json } if URL generation (upload/presign) fails.",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/OpenAIImageGenerationsResponse" },
                "examples": {
                  "url": {
                    "summary": "Example response (response_format: \"url\")",
                    "value": {
                      "created": 123,
                      "data": [
                        { "url": "https://...signed-url..." }
                      ],
                      "cost": 123,
                      "paymentSource": "<string>",
                      "remainingBalance": 123
                    }
                  },
                  "b64_json": {
                    "summary": "Example response (response_format: \"b64_json\")",
                    "value": {
                      "created": 123,
                      "data": [
                        { "b64_json": "<base64-encoded-image-bytes>" }
                      ],
                      "cost": 123,
                      "paymentSource": "<string>",
                      "remainingBalance": 123
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Unexpected error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/Error" }
              }
            }
          }
        }
      }
    },
    "/v1/tee/attestation": {
      "servers": [
        { "url": "https://nano-gpt.com", "description": "Root server for TEE endpoints" }
      ],
      "get": {
        "description": "Fetch TEE attestation report for a model",
        "security": [ { "bearerAuth": [] } ],
        "parameters": [
          { "name": "model", "in": "query", "description": "TEE model to attest", "required": true, "schema": { "type": "string" } }
        ],
        "responses": {
          "200": {
            "description": "TEE attestation report",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/TEEAttestationResponse" } } }
          },
          "400": { "description": "Bad Request", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error" } } } },
          "401": { "description": "Unauthorized" },
          "500": { "description": "Server Error" }
        }
      }
    },
    "/v1/tee/signature/{requestId}": {
      "servers": [
        { "url": "https://nano-gpt.com", "description": "Root server for TEE endpoints" }
      ],
      "get": {
        "description": "Fetch ECDSA signature for a chat request",
        "security": [ { "bearerAuth": [] } ],
        "parameters": [
          { "name": "requestId", "in": "path", "description": "Chat request ID", "required": true, "schema": { "type": "string" } },
          { "name": "model", "in": "query", "description": "TEE model to attest", "required": true, "schema": { "type": "string" } },
          { "name": "signing_algo", "in": "query", "description": "Signing algorithm to use", "required": false, "schema": { "type": "string" }, "example": "ecdsa" }
        ],
        "responses": {
          "200": {
            "description": "TEE signature response",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/TEESignatureResponse" } } }
          },
          "400": { "description": "Bad Request", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error" } } } },
          "401": { "description": "Unauthorized" },
          "500": { "description": "Server Error" }
        }
      }
    },
    "/transcribe": {
      "post": {
        "description": "Transcribe audio files into text using state-of-the-art speech recognition models. Supports multiple languages, speaker diarization, and various audio formats. Returns synchronous results for Whisper/Wizper models and asynchronous job IDs for Elevenlabs-STT.",
        "security": [
          {
            "apiKeyAuth": []
          }
        ],
        "requestBody": {
          "description": "Audio transcription parameters. Use multipart/form-data for file uploads or application/json for URL-based requests.",
          "content": {
            "multipart/form-data": {
              "schema": {
                "$ref": "#/components/schemas/TranscribeFormRequest"
              }
            },
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TranscribeJsonRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Synchronous transcription response (Whisper/Wizper models)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TranscribeResponse"
                }
              }
            }
          },
          "202": {
            "description": "Asynchronous transcription job started (Elevenlabs-STT model)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TranscribeAsyncResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request - Invalid parameters or file format",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing API key"
          },
          "402": {
            "description": "Payment Required - Insufficient balance",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large - File exceeds size limit",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/transcribe/status": {
      "post": {
        "description": "Check the status of an asynchronous transcription job (Elevenlabs-STT). Poll this endpoint to get the transcription results when the job is completed.",
        "security": [
          {
            "apiKeyAuth": []
          }
        ],
        "requestBody": {
          "description": "Status check parameters including runId from the initial transcription request",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TranscribeStatusRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Transcription status response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TranscribeStatusResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request - Missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing API key"
          },
          "404": {
            "description": "Not Found - Transcription job not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/youtube-transcribe": {
      "post": {
        "description": "Extract transcripts from YouTube videos programmatically. Supports multiple URLs per request and provides detailed response information including success/failure status for each video.",
        "security": [
          {
            "apiKeyAuth": []
          }
        ],
        "requestBody": {
          "description": "YouTube transcription parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/YouTubeTranscribeRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "YouTube transcription response with results for each URL",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/YouTubeTranscribeResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request - Please provide an array of YouTube URLs",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid session or API key"
          },
          "402": {
            "description": "Payment Required - Insufficient balance",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "429": {
            "description": "Too Many Requests - Rate limit exceeded",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/scrape-urls": {
      "post": {
        "description": "Extract clean, formatted content from web pages. Returns both raw HTML content and formatted markdown.",
        "security": [
          {
            "apiKeyAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "requestBody": {
          "description": "Web scraping parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ScrapeUrlsRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Web scraping response with results for each URL",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScrapeUrlsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request - Please provide an array of URLs to scrape",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid session or API key"
          },
          "402": {
            "description": "Payment Required - Insufficient balance",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "429": {
            "description": "Too Many Requests - Rate limit exceeded",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - An error occurred while processing your request"
          }
        }
      }
    },
    "/web": {
      "post": {
        "description": "Perform AI-powered web searches using Linkup with multiple output formats, date filtering, and domain filtering.",
        "security": [
          {
            "apiKeyAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "requestBody": {
          "description": "Web search parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebSearchRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Web search response with results based on output type",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebSearchResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request - Query parameter is required and must be a string",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid session or API key"
          },
          "402": {
            "description": "Payment Required - Insufficient balance. A minimum balance of $1.00 is required to use web search.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "429": {
            "description": "Too Many Requests - Rate limit exceeded",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - An error occurred while processing your request"
          }
        }
      }
    },
    "/transaction/create/{ticker}": {
      "post": {
        "description": "Generate a cryptocurrency deposit address via BTCPayServer integration. When crypto is sent to the generated address, the user's account balance is automatically credited.",
        "security": [
          {
            "apiKeyAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "ticker",
            "in": "path",
            "description": "Cryptocurrency ticker symbol",
            "required": true,
            "schema": {
              "type": "string",
              "enum": ["btc", "ltc", "xmr", "doge", "dash", "bch", "ban"]
            }
          }
        ],
        "requestBody": {
          "description": "Deposit amount parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CryptoDepositRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Crypto deposit address generated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CryptoDepositResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request - Invalid amount or unsupported ticker",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing API key"
          },
          "429": {
            "description": "Too Many Requests - Rate limit exceeded",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "Server Error - Payment provider unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/transaction/limits/{ticker}": {
      "get": {
        "description": "Get minimum and maximum deposit amounts for a cryptocurrency",
        "security": [
          {
            "apiKeyAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "ticker",
            "in": "path",
            "description": "Cryptocurrency ticker symbol",
            "required": true,
            "schema": {
              "type": "string",
              "enum": ["btc", "ltc", "xmr", "doge", "dash", "bch", "ban"]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Payment limits for the cryptocurrency",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CryptoLimitsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request - Unsupported ticker",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing API key"
          }
        }
      }
    },
    "/tts": {
      "post": {
        "description": "Convert text into natural-sounding speech using various TTS models from different providers. Supports multiple languages, voices, and customization options including speed control, voice instructions, and audio format selection.",
        "security": [
          {
            "apiKeyAuth": []
          }
        ],
        "requestBody": {
          "description": "Text-to-speech generation parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TTSRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Text-to-speech response. Returns either JSON with audio URL or binary audio data depending on the model.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TTSResponse"
                }
              },
              "audio/mp3": {
                "schema": {
                  "type": "string",
                  "format": "binary",
                  "description": "Binary audio data (for OpenAI models)"
                }
              },
              "audio/wav": {
                "schema": {
                  "type": "string",
                  "format": "binary",
                  "description": "Binary audio data"
                }
              },
              "audio/opus": {
                "schema": {
                  "type": "string",
                  "format": "binary",
                  "description": "Binary audio data (OpenAI models)"
                }
              },
              "audio/aac": {
                "schema": {
                  "type": "string",
                  "format": "binary",
                  "description": "Binary audio data (OpenAI models)"
                }
              },
              "audio/flac": {
                "schema": {
                  "type": "string",
                  "format": "binary",
                  "description": "Binary audio data (OpenAI models)"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request - Invalid parameters or missing text",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing API key"
          },
          "402": {
            "description": "Payment Required - Insufficient balance",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large - Text exceeds model limits",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "429": {
            "description": "Too Many Requests - Rate limit exceeded",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "501": {
            "description": "Not Implemented - Model not yet implemented",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/embeddings": {
      "post": {
        "description": "Create embeddings for text using OpenAI-compatible and alternative embedding models",
        "security": [
          {
            "bearerAuth": []
          },
          {
            "apiKeyAuth": []
          }
        ],
        "requestBody": {
          "description": "Parameters for creating embeddings",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EmbeddingRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Embedding response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EmbeddingResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request - Invalid parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing API key"
          },
          "429": {
            "description": "Rate limit exceeded"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/v1/embedding-models": {
      "get": {
        "description": "List all available embedding models with detailed information",
        "security": [
          {
            "bearerAuth": []
          },
          {
            "apiKeyAuth": []
          }
        ],
        "responses": {
          "200": {
            "description": "List of available embedding models",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EmbeddingModelsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Unexpected error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/memory": {
      "post": {
        "description": "Compress a conversation with Context Memory and return compressed messages and usage (no model inference)",
        "security": [
          { "bearerAuth": [] },
          { "apiKeyAuth": [] }
        ],
        "requestBody": {
          "description": "Parameters for memory compression",
          "required": true,
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/MemoryRequest" }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Memory compression response",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/MemoryResponse" } }
            }
          },
          "400": {
            "description": "Bad Request - Missing or invalid messages",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error" } } }
          },
          "401": { "description": "Unauthorized - Invalid or missing API key" },
          "402": {
            "description": "Payment Required - Insufficient balance",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error" } } }
          },
          "429": {
            "description": "Too Many Requests - Rate limit exceeded",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error" } } }
          }
        }
      }
    },
    "/v1/responses": {
      "post": {
        "description": "Create a response with the OpenAI-compatible Responses API",
        "security": [
          { "bearerAuth": [] },
          { "apiKeyAuth": [] }
        ],
        "requestBody": {
          "description": "Parameters for the response request",
          "required": true,
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/ResponsesCreateRequest" }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Response created",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/ResponsesResponse" } }
            }
          },
          "400": {
            "description": "Bad Request - Invalid parameters",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error" } } }
          },
          "401": { "description": "Unauthorized - Invalid or missing API key" },
          "429": {
            "description": "Too Many Requests - Rate limit exceeded",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error" } } }
          }
        }
      },
      "get": {
        "description": "Returns endpoint information for the Responses API",
        "security": [
          { "bearerAuth": [] },
          { "apiKeyAuth": [] }
        ],
        "responses": {
          "200": {
            "description": "Endpoint information",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/ResponsesInfoResponse" } }
            }
          }
        }
      }
    },
    "/v1/responses/{id}": {
      "get": {
        "description": "Retrieve a stored response by ID",
        "security": [
          { "bearerAuth": [] },
          { "apiKeyAuth": [] }
        ],
        "parameters": [
          { "name": "id", "in": "path", "description": "Response ID", "required": true, "schema": { "type": "string" } }
        ],
        "responses": {
          "200": {
            "description": "Stored response",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/ResponsesResponse" } }
            }
          },
          "401": { "description": "Unauthorized - Invalid or missing API key" },
          "404": {
            "description": "Not Found - Response does not exist",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error" } } }
          }
        }
      },
      "delete": {
        "description": "Delete a stored response (soft delete)",
        "security": [
          { "bearerAuth": [] },
          { "apiKeyAuth": [] }
        ],
        "parameters": [
          { "name": "id", "in": "path", "description": "Response ID", "required": true, "schema": { "type": "string" } }
        ],
        "responses": {
          "200": {
            "description": "Response deleted",
            "content": {
              "application/json": { "schema": { "$ref": "#/components/schemas/ResponsesDeleteResponse" } }
            }
          },
          "401": { "description": "Unauthorized - Invalid or missing API key" },
          "404": {
            "description": "Not Found - Response does not exist",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Error" } } }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "ChatCompletionRequest": {
        "type": "object",
        "required": [
          "model",
          "messages"
        ],
        "properties": {
          "model": {
            "type": "string",
            "description": "The model to use for completion. Append ':online' for web search ($0.005/request) or ':online/linkup-deep' for deep web search ($0.05/request)",
            "default": "openai/gpt-5.2",
            "examples": ["openai/gpt-5.2", "openai/gpt-5.2:online", "openai/gpt-5.2:online/linkup-deep", "anthropic/claude-opus-4.5:online"]
          },
          "messages": {
            "type": "array",
            "description": "Array of message objects with role and content",
            "default": [
              {
                "role": "user",
                "content": "Testing, please reply!"
              }
            ],
            "items": {
              "type": "object",
              "required": [
                "role",
                "content"
              ],
              "properties": {
                "role": {
                  "type": "string",
                  "description": "The role of the message author",
                  "enum": ["system", "user", "assistant"]
                },
                "content": {
                  "description": "Message content as a simple string or an array of multimodal parts",
                  "oneOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/MessageContentPart"
                      }
                    }
                  ]
                }
              }
            }
          },
          "stream": {
            "type": "boolean",
            "description": "Whether to stream the response",
            "default": false
          },
          "service_tier": {
            "type": "string",
            "enum": ["auto", "default", "flex", "priority"],
            "description": "Optional service tier. Set to \"priority\" to request priority processing when supported by the routed provider"
          },
          "temperature": {
            "type": "number",
            "description": "Classic randomness control. Accepts any decimal between 0-2. Lower numbers bias toward deterministic responses, higher values explore more aggressively",
            "minimum": 0,
            "maximum": 2,
            "default": 0.7
          },
          "max_tokens": {
            "type": "integer",
            "description": "Upper bound on generated tokens",
            "default": 4000,
            "minimum": 1
          },
          "top_p": {
            "type": "number",
            "description": "Nucleus sampling. When set below 1.0, trims candidate tokens to the smallest set whose cumulative probability exceeds top_p. Works well as an alternative to tweaking temperature",
            "minimum": 0,
            "maximum": 1,
            "default": 1
          },
          "frequency_penalty": {
            "type": "number",
            "description": "Penalizes tokens proportionally to how often they appeared previously. Negative values encourage repetition; positive values discourage it",
            "minimum": -2.0,
            "maximum": 2.0,
            "default": 0
          },
          "presence_penalty": {
            "type": "number",
            "description": "Penalizes tokens based on whether they appeared at all. Good for keeping the model on topic without outright banning words",
            "minimum": -2.0,
            "maximum": 2.0,
            "default": 0
          },
          "repetition_penalty": {
            "type": "number",
            "description": "Provider-agnostic repetition modifier (distinct from OpenAI penalties). Values >1 discourage repetition",
            "minimum": -2.0,
            "maximum": 2.0
          },
          "top_k": {
            "type": "integer",
            "description": "Caps sampling to the top-k highest probability tokens per step"
          },
          "top_a": {
            "type": "number",
            "description": "Combines top-p and temperature behavior; leave unset unless a model description explicitly calls for it"
          },
          "min_p": {
            "type": "number",
            "description": "Ensures each candidate token probability exceeds a floor (0-1). Helpful for stopping models from collapsing into low-entropy loops",
            "minimum": 0,
            "maximum": 1
          },
          "tfs": {
            "type": "number",
            "description": "Tail free sampling. Values between 0-1 let you shave the long tail of the distribution; 1.0 disables the feature",
            "minimum": 0,
            "maximum": 1
          },
          "eta_cutoff": {
            "type": "number",
            "description": "Cut probabilities as soon as they fall below the specified tail threshold"
          },
          "epsilon_cutoff": {
            "type": "number",
            "description": "Cut probabilities as soon as they fall below the specified tail threshold"
          },
          "typical_p": {
            "type": "number",
            "description": "Typical sampling (aka entropy-based nucleus). Works like top_p but preserves tokens whose surprise matches the expected entropy",
            "minimum": 0,
            "maximum": 1
          },
          "mirostat_mode": {
            "type": "integer",
            "description": "Enables Mirostat sampling for models that support it. Set to 1 or 2 to activate",
            "enum": [0, 1, 2]
          },
          "mirostat_tau": {
            "type": "number",
            "description": "Mirostat target entropy parameter. Used when mirostat_mode is enabled"
          },
          "mirostat_eta": {
            "type": "number",
            "description": "Mirostat learning rate parameter. Used when mirostat_mode is enabled"
          },
          "min_tokens": {
            "type": "integer",
            "description": "For providers that support it, enforces a minimum completion length before stop conditions fire",
            "default": 0,
            "minimum": 0
          },
          "stop": {
            "description": "Stop sequences. Accepts string or array of strings. Values are passed directly to upstream providers",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ]
          },
          "stop_token_ids": {
            "type": "array",
            "description": "Numeric array that lets callers stop generation on specific token IDs. Not supported by many providers",
            "items": {
              "type": "integer"
            }
          },
          "include_stop_str_in_output": {
            "type": "boolean",
            "description": "When true, keeps the stop sequence in the final text. Not supported by many providers",
            "default": false
          },
          "ignore_eos": {
            "type": "boolean",
            "description": "Allows completions to continue even if the model predicts EOS internally. Useful for long creative writing runs",
            "default": false
          },
          "no_repeat_ngram_size": {
            "type": "integer",
            "description": "Extension that forbids repeating n-grams of the given size. Not supported by many providers",
            "minimum": 0
          },
          "custom_token_bans": {
            "type": "array",
            "description": "List of token IDs to fully block",
            "items": {
              "type": "integer"
            }
          },
          "logit_bias": {
            "type": "object",
            "description": "Object mapping token IDs to additive logits. Works just like OpenAI's version",
            "additionalProperties": {
              "type": "number"
            }
          },
          "logprobs": {
            "description": "When true or a number, forwards the request to providers that support returning token-level log probabilities",
            "oneOf": [
              {
                "type": "boolean"
              },
              {
                "type": "integer"
              }
            ]
          },
          "prompt_logprobs": {
            "type": "boolean",
            "description": "Requests logprobs on the prompt itself when the upstream API allows it"
          },
          "seed": {
            "type": "integer",
            "description": "Numeric seed. Wherever supported, passes the value to make completions repeatable"
          },
          "prompt_caching": {
            "type": "object",
            "description": "Helper to tag the leading messages for Claude prompt caching. NanoGPT injects cache_control blocks on each message up to the specified index before forwarding to Anthropic.",
            "properties": {
              "enabled": {
                "type": "boolean",
                "description": "Whether to enable prompt caching on this request",
                "default": false
              },
              "ttl": {
                "type": "string",
                "description": "Cache time-to-live ('5m' or '1h')",
                "enum": ["5m", "1h"],
                "example": "5m"
              },
              "cut_after_message_index": {
                "type": "integer",
                "minimum": 0,
                "description": "Zero-based index of the last message that should be cached. All messages up to and including this index receive the same cache_control block."
              }
            }
          }
        }
      },
      "MessageContentPart": {
        "type": "object",
        "required": ["type"],
        "additionalProperties": true,
        "properties": {
          "type": {
            "type": "string",
            "description": "Content block type",
            "enum": ["text", "image_url", "input_text", "input_audio", "input_video", "tool_use", "tool_result"]
          },
          "text": {
            "type": "string",
            "description": "Text content when type is 'text'"
          },
          "image_url": {
            "type": "object",
            "description": "Image reference for multimodal prompts",
            "properties": {
              "url": {
                "type": "string",
                "description": "HTTPS URL or base64 data URL for the image"
              },
              "detail": {
                "type": "string",
                "description": "Requested image resolution detail",
                "enum": ["low", "high", "auto"]
              }
            }
          },
          "input_audio": {
            "type": "object",
            "description": "Inline audio input payload",
            "properties": {
              "data": {
                "type": "string",
                "description": "Base64 encoded audio bytes"
              },
              "format": {
                "type": "string",
                "description": "Audio format (e.g. wav, mp3)"
              }
            }
          },
          "input_video": {
            "type": "object",
            "description": "Inline video reference",
            "properties": {
              "video_url": {
                "type": "string",
                "description": "HTTPS URL or data URL for the video"
              }
            }
          },
          "cache_control": {
            "type": "object",
            "description": "Claude-only prompt caching control applied to this block. When present, NanoGPT forwards it unchanged to Anthropic.",
            "properties": {
              "type": {
                "type": "string",
                "enum": ["ephemeral"],
                "description": "Cache type. Claude currently exposes the 'ephemeral' tier for 5m/1h TTLs."
              },
              "ttl": {
                "type": "string",
                "enum": ["5m", "1h"],
                "description": "Optional TTL override for this block."
              }
            }
          }
        }
      },
      "ChatCompletionResponse": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for the completion"
          },
          "object": {
            "type": "string",
            "description": "Object type, always 'chat.completion'"
          },
          "created": {
            "type": "integer",
            "description": "Unix timestamp of when the completion was created"
          },
          "choices": {
            "type": "array",
            "description": "Array of completion choices",
            "items": {
              "type": "object",
              "properties": {
                "index": {
                  "type": "integer",
                  "description": "Index of the choice"
                },
                "message": {
                  "type": "object",
                  "properties": {
                    "role": {
                      "type": "string",
                      "description": "Role of the completion message",
                      "enum": ["assistant"]
                    },
                    "content": {
                      "type": "string",
                      "description": "Content of the completion message"
                    }
                  }
                },
                "finish_reason": {
                  "type": "string",
                  "description": "Reason why the completion finished",
                  "enum": ["stop", "length", "content_filter"]
                }
              }
            }
          },
          "usage": {
            "type": "object",
            "properties": {
              "prompt_tokens": {
                "type": "integer",
                "description": "Number of tokens in the prompt"
              },
              "completion_tokens": {
                "type": "integer",
                "description": "Number of tokens in the completion"
              },
              "total_tokens": {
                "type": "integer",
                "description": "Total number of tokens used"
              }
            }
          },
          "service_tier": {
            "type": "string",
            "description": "Service tier used (echoed when provided on the request)"
          }
        }
      },
      "CompletionRequest": {
        "type": "object",
        "required": [
          "model",
          "prompt"
        ],
        "properties": {
          "model": {
            "type": "string",
            "description": "The model to use for completion. Append ':online' for web search ($0.005/request) or ':online/linkup-deep' for deep web search ($0.05/request)",
            "default": "openai/gpt-5.2",
            "examples": ["openai/gpt-5.2", "openai/gpt-5.2:online", "openai/gpt-5.2:online/linkup-deep", "anthropic/claude-opus-4.5:online"]
          },
          "prompt": {
            "type": "string",
            "description": "The text prompt to complete"
          },
          "max_tokens": {
            "type": "integer",
            "description": "Upper bound on generated tokens",
            "default": 4000,
            "minimum": 1
          },
          "temperature": {
            "type": "number",
            "description": "Classic randomness control. Accepts any decimal between 0-2. Lower numbers bias toward deterministic responses, higher values explore more aggressively",
            "minimum": 0,
            "maximum": 2,
            "default": 0.7
          },
          "top_p": {
            "type": "number",
            "description": "Nucleus sampling. When set below 1.0, trims candidate tokens to the smallest set whose cumulative probability exceeds top_p. Works well as an alternative to tweaking temperature",
            "minimum": 0,
            "maximum": 1,
            "default": 1
          },
          "stream": {
            "type": "boolean",
            "description": "Whether to stream the response",
            "default": false
          },
          "stop": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ],
            "description": "Stop sequences. Accepts string or array of strings. Values are passed directly to upstream providers"
          },
          "frequency_penalty": {
            "type": "number",
            "description": "Penalizes tokens proportionally to how often they appeared previously. Negative values encourage repetition; positive values discourage it",
            "minimum": -2.0,
            "maximum": 2.0,
            "default": 0
          },
          "presence_penalty": {
            "type": "number",
            "description": "Penalizes tokens based on whether they appeared at all. Good for keeping the model on topic without outright banning words",
            "minimum": -2.0,
            "maximum": 2.0,
            "default": 0
          },
          "repetition_penalty": {
            "type": "number",
            "description": "Provider-agnostic repetition modifier (distinct from OpenAI penalties). Values >1 discourage repetition",
            "minimum": -2.0,
            "maximum": 2.0
          },
          "top_k": {
            "type": "integer",
            "description": "Caps sampling to the top-k highest probability tokens per step"
          },
          "top_a": {
            "type": "number",
            "description": "Combines top-p and temperature behavior; leave unset unless a model description explicitly calls for it"
          },
          "min_p": {
            "type": "number",
            "description": "Ensures each candidate token probability exceeds a floor (0-1). Helpful for stopping models from collapsing into low-entropy loops",
            "minimum": 0,
            "maximum": 1
          },
          "tfs": {
            "type": "number",
            "description": "Tail free sampling. Values between 0-1 let you shave the long tail of the distribution; 1.0 disables the feature",
            "minimum": 0,
            "maximum": 1
          },
          "eta_cutoff": {
            "type": "number",
            "description": "Cut probabilities as soon as they fall below the specified tail threshold"
          },
          "epsilon_cutoff": {
            "type": "number",
            "description": "Cut probabilities as soon as they fall below the specified tail threshold"
          },
          "typical_p": {
            "type": "number",
            "description": "Typical sampling (aka entropy-based nucleus). Works like top_p but preserves tokens whose surprise matches the expected entropy",
            "minimum": 0,
            "maximum": 1
          },
          "mirostat_mode": {
            "type": "integer",
            "description": "Enables Mirostat sampling for models that support it. Set to 1 or 2 to activate",
            "enum": [0, 1, 2]
          },
          "mirostat_tau": {
            "type": "number",
            "description": "Mirostat target entropy parameter. Used when mirostat_mode is enabled"
          },
          "mirostat_eta": {
            "type": "number",
            "description": "Mirostat learning rate parameter. Used when mirostat_mode is enabled"
          },
          "min_tokens": {
            "type": "integer",
            "description": "For providers that support it, enforces a minimum completion length before stop conditions fire",
            "default": 0,
            "minimum": 0
          },
          "stop_token_ids": {
            "type": "array",
            "description": "Numeric array that lets callers stop generation on specific token IDs. Not supported by many providers",
            "items": {
              "type": "integer"
            }
          },
          "include_stop_str_in_output": {
            "type": "boolean",
            "description": "When true, keeps the stop sequence in the final text. Not supported by many providers",
            "default": false
          },
          "ignore_eos": {
            "type": "boolean",
            "description": "Allows completions to continue even if the model predicts EOS internally. Useful for long creative writing runs",
            "default": false
          },
          "no_repeat_ngram_size": {
            "type": "integer",
            "description": "Extension that forbids repeating n-grams of the given size. Not supported by many providers",
            "minimum": 0
          },
          "custom_token_bans": {
            "type": "array",
            "description": "List of token IDs to fully block",
            "items": {
              "type": "integer"
            }
          },
          "logit_bias": {
            "type": "object",
            "description": "Object mapping token IDs to additive logits. Works just like OpenAI's version",
            "additionalProperties": {
              "type": "number"
            }
          },
          "logprobs": {
            "description": "When true or a number, forwards the request to providers that support returning token-level log probabilities",
            "oneOf": [
              {
                "type": "boolean"
              },
              {
                "type": "integer"
              }
            ]
          },
          "prompt_logprobs": {
            "type": "boolean",
            "description": "Requests logprobs on the prompt itself when the upstream API allows it"
          },
          "seed": {
            "type": "integer",
            "description": "Numeric seed. Wherever supported, passes the value to make completions repeatable"
          }
        }
      },
      "CompletionResponse": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for the completion"
          },
          "object": {
            "type": "string",
            "description": "Object type, always 'text_completion'"
          },
          "created": {
            "type": "integer",
            "description": "Unix timestamp of when the completion was created"
          },
          "model": {
            "type": "string",
            "description": "Model used for completion"
          },
          "choices": {
            "type": "array",
            "description": "Array of completion choices",
            "items": {
              "type": "object",
              "properties": {
                "text": {
                  "type": "string",
                  "description": "The completed text"
                },
                "index": {
                  "type": "integer",
                  "description": "Index of the choice"
                },
                "logprobs": {
                  "type": "object",
                  "nullable": true,
                  "description": "Log probabilities of tokens (if requested)"
                },
                "finish_reason": {
                  "type": "string",
                  "description": "Reason why the completion finished",
                  "enum": ["stop", "length", "content_filter"]
                }
              }
            }
          },
          "usage": {
            "type": "object",
            "properties": {
              "prompt_tokens": {
                "type": "integer",
                "description": "Number of tokens in the prompt"
              },
              "completion_tokens": {
                "type": "integer",
                "description": "Number of tokens in the completion"
              },
              "total_tokens": {
                "type": "integer",
                "description": "Total number of tokens used"
              }
            }
          }
        }
      },
      "ImageGenerationRequest": {
        "type": "object",
        "required": [
          "prompt",
          "model"
        ],
        "properties": {
          "prompt": {
            "type": "string",
            "description": "The text description of the image to generate",
            "example": "RAW photo, a portrait photo of a latina woman in casual clothes, natural skin, 8k uhd, high quality, film grain, Fujifilm XT3"
          },
          "model": {
            "type": "string",
            "description": "The model to use for generation",
            "default": "recraft-v3"
          },
          "width": {
            "type": "integer",
            "description": "Width of the generated image",
            "default": 1024
          },
          "height": {
            "type": "integer",
            "description": "Height of the generated image",
            "default": 1024
          },
          "negative_prompt": {
            "type": "string",
            "description": "Things to avoid in the generated image"
          },
          "nImages": {
            "type": "integer",
            "description": "Number of images to generate",
            "default": 1
          },
          "num_steps": {
            "type": "integer",
            "description": "Number of denoising steps",
            "default": 10
          },
          "resolution": {
            "type": "string",
            "description": "Output resolution",
            "default": "1024x1024"
          },
          "sampler_name": {
            "type": "string",
            "description": "Sampling method"
          },
          "scale": {
            "type": "number",
            "description": "Guidance scale",
            "default": 7.5
          },
          "imageDataUrl": {
            "type": "string",
            "description": "Base64-encoded image data URL for img2img generation (format: data:image/[type];base64,[data])",
            "example": "data:image/jpeg;base64,/9j/4AAQ..."
          },
          "kontext_max_mode": {
            "type": "boolean",
            "description": "When using flux-kontext model, enables maximum context mode for better image understanding",
            "default": false
          }
        }
      },
      "ImageGenerationResponse": {
        "type": "object",
        "properties": {
          "image": {
            "type": "string",
            "description": "Base64 encoded image data"
          },
          "cost": {
            "type": "number",
            "description": "Cost of the generation"
          },
          "inputTokens": {
            "type": "integer",
            "description": "Number of input tokens used"
          },
          "outputTokens": {
            "type": "integer",
            "description": "Number of output tokens used"
          }
        }
      },
      "Error": {
        "required": [
          "error",
          "message"
        ],
        "type": "object",
        "properties": {
          "error": {
            "type": "integer",
            "format": "int32"
          },
          "message": {
            "type": "string"
          }
        }
      },
      "TalkToGptRequest": {
        "type": "object",
        "required": [
          "model"
        ],
        "properties": {
          "prompt": {
            "type": "string",
            "description": "The text prompt to send to GPT (optional)",
            "default": "",
            "example": "Please explain the concept of artificial intelligence."
          },
          "model": {
            "type": "string",
            "description": "The model to use for generation. Append ':online' for web search ($0.005/request) or ':online/linkup-deep' for deep web search ($0.05/request)",
            "default": "openai/gpt-5.2",
            "examples": ["openai/gpt-5.2", "openai/gpt-5.2:online", "anthropic/claude-opus-4.5:online/linkup-deep"]
          },
          "messages": {
            "type": "array",
            "description": "Array of previous message objects for context (optional)",
            "default": [
              {
                "role": "user",
                "content": "Hi, I'm just testing!"
              }
            ],
            "items": {
              "type": "object",
              "required": [
                "role",
                "content"
              ],
              "properties": {
                "role": {
                  "type": "string", 
                  "description": "The role of the message author",
                  "enum": ["user", "assistant"]
                },
                "content": {
                  "type": "string",
                  "description": "The content of the message"
                }
              }
            }
          }
        }
      },
      "ModelsResponse": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "description": "Type of object, always 'list' for the models response",
            "default": "list"
          },
          "data": {
            "type": "array",
            "description": "List of available models",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "description": "Unique identifier for the model",
                  "example": "openai/gpt-5.2"
                },
                "object": {
                  "type": "string",
                  "description": "Type of object, always 'model'",
                  "default": "model"
                },
                "created": {
                  "type": "integer",
                  "description": "Unix timestamp when the model was created"
                },
                "owned_by": {
                  "type": "string",
                  "description": "Organization that owns the model",
                  "example": "openai"
                },
                "name": {
                  "type": "string",
                  "description": "Human-readable model name (detailed mode only)",
                  "example": "GPT-4o Mini"
                },
                "description": {
                  "type": "string",
                  "description": "Detailed model description (detailed mode only)",
                  "example": "OpenAI's affordable and intelligent small model for fast, lightweight tasks"
                },
                "context_length": {
                  "type": "integer",
                  "description": "Maximum input tokens (detailed mode only, null if not available)",
                  "example": 128000
                },
                "pricing": {
                  "type": "object",
                  "description": "Pricing information object (detailed mode only)",
                  "properties": {
                    "prompt": {
                      "type": "number",
                      "description": "Cost per million input tokens in USD",
                      "example": 0.00015
                    },
                    "completion": {
                      "type": "number",
                      "description": "Cost per million output tokens in USD",
                      "example": 0.0006
                    },
                    "currency": {
                      "type": "string",
                      "description": "Always 'USD'",
                      "default": "USD"
                    },
                    "unit": {
                      "type": "string",
                      "description": "Always 'per_million_tokens'",
                      "default": "per_million_tokens"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "ModelsLegacyResponse": {
        "type": "object",
        "properties": {
          "models": {
            "type": "array",
            "description": "List of available model names",
            "items": {
              "type": "string",
              "description": "Model identifier",
              "example": "openai/gpt-5.2"
            }
          }
        }
      },
      "BalanceResponse": {
        "type": "object",
        "properties": {
          "usd_balance": {
            "type": "string",
            "description": "Account balance in USD",
            "example": "129.46956147"
          },
          "nano_balance": {
            "type": "string",
            "description": "Account balance in Nano",
            "example": "26.71801147"
          },
          "nanoDepositAddress": {
            "type": "string",
            "description": "Nano deposit address for the account",
            "example": "nano_1gx385nnj7rw67hsksa3pyxwnfr48zu13t35ncjmtnqb9zdebtjhh7ahks34"
          }
        }
      },
      "ReceiveNanoResponse": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Whether the operation was successful"
          },
          "received_blocks": {
            "type": "array",
            "description": "Array of received block hashes",
            "items": {
              "type": "string"
            }
          },
          "total_received": {
            "type": "string",
            "description": "Total amount of Nano received"
          }
        }
      },
      "NsfwImageRequest": {
        "type": "object",
        "description": "NSFW image classification request payload",
        "properties": {
          "image_urls": {
            "description": "Primary input field. One URL or an array of URLs (only the first 10 are processed).",
            "oneOf": [
              {
                "type": "string",
                "format": "uri",
                "example": "https://example.com/image.jpg"
              },
              {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uri"
                },
                "minItems": 1,
                "example": [
                  "https://example.com/image-1.jpg",
                  "https://example.com/image-2.jpg"
                ]
              }
            ]
          },
          "imageUrls": {
            "description": "Alias for image_urls. One URL or an array of URLs (only the first 10 are processed).",
            "oneOf": [
              {
                "type": "string",
                "format": "uri",
                "example": "https://example.com/image.jpg"
              },
              {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uri"
                },
                "minItems": 1
              }
            ]
          },
          "imageUrl": {
            "type": "string",
            "format": "uri",
            "description": "Alias for a single image URL",
            "example": "https://example.com/image.jpg"
          },
          "imageDataUrl": {
            "type": "string",
            "description": "Base64 data URL for a single image (format: data:image/[type];base64,[data])",
            "example": "data:image/jpeg;base64,/9j/4AAQ..."
          },
          "imageDataUrls": {
            "type": "array",
            "description": "Base64 data URLs for multiple images (only the first 10 are processed)",
            "items": {
              "type": "string"
            },
            "minItems": 1
          },
          "model": {
            "type": "string",
            "description": "Only supported value is nsfw-classifier",
            "default": "nsfw-classifier"
          }
        }
      },
      "NsfwImageResponse": {
        "type": "object",
        "properties": {
          "model": {
            "type": "string",
            "description": "The classifier model used",
            "example": "nsfw-classifier"
          },
          "requestId": {
            "type": "string",
            "description": "Request ID (if available; helpful for support)"
          },
          "inputCount": {
            "type": "integer",
            "description": "Number of images processed (max 10)",
            "example": 2
          },
          "cost": {
            "type": "number",
            "description": "Final charged amount (after discounts and currency conversion)",
            "example": 0.003
          },
          "currency": {
            "type": "string",
            "description": "Currency of the charge",
            "example": "USD"
          },
          "truncated": {
            "type": "boolean",
            "description": "True if more than 10 images were provided",
            "example": false
          },
          "has_nsfw_concepts": {
            "type": "array",
            "description": "Per-image NSFW flags in input order",
            "items": {
              "type": "boolean"
            },
            "example": [
              false,
              true
            ]
          },
          "is_nsfw": {
            "type": "boolean",
            "description": "True if any image was flagged",
            "example": true
          }
        }
      },
      "VideoGenerationRequest": {
        "type": "object",
        "required": ["model"],
        "properties": {
          "model": {
            "type": "string",
            "description": "The video model to use for generation. See the docs for the current model list and required inputs."
          },
          "prompt": {
            "type": "string",
            "description": "Text prompt describing the video to generate",
            "example": "A serene lake at sunset with gentle ripples on the water"
          },
          "script": {
            "type": "string",
            "description": "Fully-written script for LongStories models (takes precedence over prompt)"
          },
          "conversationUUID": {
            "type": "string",
            "description": "UUID for conversation tracking"
          },
          "projectId": {
            "type": "string",
            "description": "Project identifier for LongStories models"
          },
          "framework": {
            "type": "string",
            "description": "Story framework for LongStories models",
            "enum": ["default", "emotional_story", "product_showcase", "tutorial"],
            "default": "default"
          },
          "shortRequestEnhancer": {
            "type": "boolean",
            "description": "Smart Enhancement: if true, automatically choose better framework and add Director Notes if necessary",
            "default": false
          },
          "targetLengthInWords": {
            "type": "integer",
            "description": "Target length in words for LongStories models (legacy parameter)",
            "default": 70
          },
          "targetLengthInSeconds": {
            "type": "integer",
            "description": "Target length in seconds (alternative to words)"
          },
          "directorNotes": {
            "type": "string",
            "description": "Prompt for the image generation engine (LongStories). Example: 'Warm lighting' or 'Make the first image very impactful'",
            "example": "Warm, cozy lighting with focus on people interacting"
          },
          "aspectRatio": {
            "type": "string",
            "description": "Video aspect ratio for LongStories",
            "enum": ["9:16", "16:9"],
            "default": "9:16"
          },
          "scriptConfig": {
            "type": "object",
            "description": "Script generation configuration for LongStories",
            "properties": {
              "style": {
                "type": "string",
                "description": "Sets the tone & voice of the generated script",
                "enum": [
                  "default", "no_style", "engaging_conversational", "dixit_biography", 
                  "kind_biography", "hero_journey", "emotional_story", "dramatic_reveal",
                  "heartwarming_stories", "educational_history", "news_brief"
                ],
                "default": "default"
              },
              "targetLengthInSeconds": {
                "type": "integer",
                "description": "Approx. time length of the script in seconds. The actual length may vary slightly.",
                "minimum": 5,
                "maximum": 600,
                "default": 30
              }
            }
          },
          "imageConfig": {
            "type": "object",
            "description": "Image generation configuration for LongStories",
            "properties": {
              "model": {
                "type": "string",
                "description": "Which image model to use for generating images",
                "enum": [
                  "flux_schnell", "flux_lora", "flux_pro", "flux_pro_ultra", "flux-kontext", "recraft",
                  "sdxl", "sdxl_lora", "sd35_large", "sd35_medium", "sd35_large_turbo",
                  "leonardo_flux_precision", "leonardo_phoenix_quality", "leonardo_phoenix_ultra",
                  "reve-v1", "hidream_fast", "hidream_dev", "hidream_full", "gpt_image_1",
                  "imagen4_preview", "midjourney"
                ],
                "default": "hidream_dev"
              },
              "loraConfig": {
                "type": "object",
                "description": "Style configuration (only applies when using Flux LoRA model)",
                "properties": {
                  "loraSlug": {
                    "type": "string",
                    "description": "Specialized style to apply",
                    "enum": [
                      "ghibsky-comic-book", "colour-sketches", "sketch-paint", "90s-anime",
                      "2000s-crime-thrillers", "xno-symbol-flux"
                    ],
                    "default": "ghibsky-comic-book"
                  }
                }
              }
            }
          },
          "videoConfig": {
            "type": "object",
            "description": "Video generation configuration for LongStories",
            "properties": {
              "enabled": {
                "type": "boolean",
                "description": "Generate video motion from images instead of using static images",
                "default": true
              },
              "model": {
                "type": "string",
                "description": "Which video model to use for motion generation",
                "enum": [
                  "ltx_video_13b_distilled", "ltx_video", "stable_video", "motion",
                  "kling_v1_6_std_5s", "kling_v2_1_std_5s", "ltx_video_13b_dev", "skyreels",
                  "vidu", "kling_v1_6_std_10s", "kling_v2_1_std_10s", "kling_v2_1_pro_5s",
                  "luma_ray2", "kling_pro_5s", "minimax", "wan_i2v", "motion_2",
                  "kling_v2_1_pro_10s", "wan_pro", "luma_ray2_hd", "kling_pro_10s",
                  "kling_v2_1_master_5s", "kling_v2_master_5s", "veo2", "kling_v2_1_master_10s",
                  "kling_v2_master_10s"
                ],
                "default": "kling_v2_1_std_5s"
              }
            }
          },
          "voiceoverConfig": {
            "type": "object",
            "description": "Voiceover configuration for LongStories",
            "properties": {
              "enabled": {
                "type": "boolean",
                "description": "Enable AI voiceover for the video",
                "default": true
              },
              "voiceId": {
                "type": "string",
                "description": "Voice for video narration",
                "enum": [
                  "9BWtsMINqrJLrRacOk9x", "CwhRBWXzGAHq8TQ4Fs17", "EXAVITQu4vr4xnSDxMaL",
                  "FGY2WhTYpPnrIDTdsKH5", "IKne3meq5aSn9XLyUdCD", "JBFqnCBsd6RMkjVDRZzb",
                  "N2lVS1w4EtoT3dr4eOWO", "SAz9YHcvj6GT2YYXdXww", "TX3LPaxmHKxFdv7VOQHJ",
                  "XB0fDUnXU5powFXDhCwa", "Xb7hH8MSUJpSbSDYk0k2", "XrExE9yKIg1WjnnlVkGX",
                  "bIHbv24MWmeRgasZH58o", "cgSgspJ2msm6clMCkdW9", "cjVigY5qzO86Huf0OWal",
                  "nPczCjzI2devNBz1zQrb", "onwK4e9ZLuTAKqWW03F9", "pqHfZKP75CvOlQylNhV4",
                  "pFZP5JQG7iQjIQuC4Bku", "KHCvMklQZZo0O30ERnVn", "Nh2zY9kknu6z4pZy6FhD",
                  "LlZr3QuzbW4WrPjgATHG", "YExhVa4bZONzeingloMX", "m1VE7dnwBN0zMer3LcKv",
                  "zWDA589rUKXuLnPRDtAG", "YYHkBdgrAwQWIaH6m2ai"
                ],
                "default": "zWDA589rUKXuLnPRDtAG"
              }
            }
          },
          "captionsConfig": {
            "type": "object",
            "description": "Captions configuration for LongStories",
            "properties": {
              "captionsEnabled": {
                "type": "boolean",
                "description": "Show text captions in the video",
                "default": true
              },
              "captionsStyle": {
                "type": "string",
                "description": "Style of video captions",
                "enum": [
                  "default", "minimal", "neon", "cinematic", "fancy", "tiktok", "highlight",
                  "gradient", "intellectual", "vida", "manuscripts", "subtitle", "modern",
                  "bounce", "popcorn", "typewriter", "handwritten", "karaoke", "retro", "gaming"
                ],
                "default": "tiktok"
              }
            }
          },
          "effectsConfig": {
            "type": "object",
            "description": "Effects configuration for LongStories",
            "properties": {
              "transition": {
                "type": "string",
                "description": "Transition style between different images",
                "enum": ["fade", "random", "slide", "wipe", "flip", "none"],
                "default": "fade"
              },
              "floating": {
                "type": "boolean",
                "description": "Make the images move around slightly with floating effects",
                "default": true
              }
            }
          },
          "musicConfig": {
            "type": "object",
            "description": "Music configuration for LongStories",
            "properties": {
              "enabled": {
                "type": "boolean",
                "description": "Add background music to the video",
                "default": true
              },
              "musicSlug": {
                "type": "string",
                "description": "Choose background music for your video",
                "enum": [
                  "", "temple_of_treasures", "gentle_ambient_loop", "serene_ambience",
                  "soothing_ambience", "soothing_ambient_backdrop", "tranquil_ambience",
                  "dreamscape", "belonging_resonance", "vivid_memories", "cinematic_intro",
                  "cinematic_teaser", "dramatic_cinematic_score", "thriller_cinema_trailer",
                  "fractured_paintings", "promise_of_tomorrow", "spooky_orchestral_theme",
                  "light_upbeat_melody", "puzzle_time", "stomping_drums_rhythm",
                  "stomps_and_claps_rhythm_track", "news_theme", "adventurous_intro",
                  "burlesque_sweetheart", "highway_nocturne_national_sweetheart", "haptic_sensation"
                ],
                "default": "gentle_ambient_loop"
              },
              "volume": {
                "type": "number",
                "description": "Volume level for background music",
                "minimum": 0,
                "maximum": 1,
                "default": 0.3
              },
              "loop": {
                "type": "boolean",
                "description": "Whether to loop the background music",
                "default": true
              }
            }
          },
          "voice": {
            "type": "string",
            "description": "Legacy: Voice ID for narration (use voiceoverConfig.voiceId instead)",
            "example": "pNInz6obpgDQGcFmaJgB"
          },
          "captionsShow": {
            "type": "boolean",
            "description": "Legacy: Whether to show captions (use captionsConfig.captionsEnabled instead)",
            "default": true
          },
          "captionsStyle": {
            "type": "string",
            "description": "Legacy: Style for captions (use captionsConfig.captionsStyle instead)",
            "enum": ["default", "minimal", "neon", "cinematic", "fancy", "tiktok", "highlight", "gradient", "instagram", "vida", "manuscripts"],
            "default": "default"
          },
          "effects": {
            "type": "object",
            "description": "Legacy: Video effects configuration (use effectsConfig instead)",
            "properties": {
              "transition": {
                "type": "string",
                "default": "fade"
              },
              "floating": {
                "type": "boolean",
                "default": false
              }
            }
          },
          "quality": {
            "type": "string",
            "description": "Legacy: Video quality (handled by videoConfig now)",
            "enum": ["low", "medium", "high"],
            "default": "medium"
          },
          "motion": {
            "type": "object",
            "description": "Legacy: Motion configuration (handled by videoConfig now)",
            "properties": {
              "enabled": {
                "type": "boolean",
                "default": false
              },
              "strength": {
                "type": "integer",
                "minimum": 1,
                "maximum": 10,
                "default": 3
              }
            }
          },
          "music": {
            "type": "string",
            "description": "Legacy: Music track (use musicConfig instead)",
            "example": "video-creation/music/dramatic_cinematic_score.mp3"
          },
          "duration": {
            "oneOf": [
              {"type": "string"},
              {"type": "integer"}
            ],
            "description": "Video duration (format varies by model - '5s' for Veo2, '5' for Kling, etc.)",
            "example": "5s"
          },
          "aspect_ratio": {
            "type": "string",
            "description": "Aspect ratio for FAL models",
            "enum": ["16:9", "9:16", "1:1", "4:3", "3:4"],
            "default": "16:9"
          },
          "negative_prompt": {
            "type": "string",
            "description": "Negative prompt to avoid certain elements",
            "example": "blur, distort, and low quality"
          },
          "cfg_scale": {
            "type": "number",
            "description": "Classifier-free guidance scale",
            "minimum": 0,
            "maximum": 20,
            "default": 0.5
          },
          "imageDataUrl": {
            "type": "string",
            "description": "Base64 data URL of input image for image-to-video models. Aliases `image_data_url` and `image` are also accepted and normalized.",
            "example": "data:image/jpeg;base64,/9j/4AAQ..."
          },
          "imageUrl": {
            "type": "string",
            "description": "Public HTTPS URL of the input image (interchangeable with imageDataUrl). The service will prioritize whichever field you supply before falling back to library attachments.",
            "example": "https://images.unsplash.com/photo-1504196606672-aef5c9cefc92?w=1024"
          },
          "imageAttachmentId": {
            "type": "string", 
            "description": "Library attachment ID for input image"
          },
          "videoUrl": {
            "type": "string",
            "description": "Public HTTPS URL of the input video (extend/edit/upscale). Preferred field name for source videos."
          },
          "videoDataUrl": {
            "type": "string",
            "description": "Base64 data URL of the input video."
          },
          "video": {
            "type": "string",
            "description": "Alternate video field accepted by select providers."
          },
          "videoAttachmentId": {
            "type": "string",
            "description": "Library attachment ID for input video."
          },
          "prompt_optimizer": {
            "type": "boolean",
            "description": "Whether to optimize the prompt (MiniMax model)",
            "default": true
          },
          "num_inference_steps": {
            "type": "integer",
            "description": "Number of inference steps",
            "minimum": 1,
            "maximum": 50,
            "default": 30
          },
          "pro_mode": {
            "type": "boolean",
            "description": "Enable pro mode for Hunyuan Video",
            "default": false
          },
          "resolution": {
            "type": "string",
            "description": "Video resolution",
            "enum": ["720p", "1080p", "540p"],
            "default": "720p"
          },
          "num_frames": {
            "oneOf": [
              {"type": "integer"},
              {"type": "string"}
            ],
            "description": "Number of frames to generate",
            "default": 81
          },
          "frames_per_second": {
            "type": "integer",
            "description": "Frames per second",
            "minimum": 5,
            "maximum": 24,
            "default": 16
          },
          "seed": {
            "type": "integer",
            "description": "Random seed for reproducible results"
          },
          "enable_safety_checker": {
            "type": "boolean",
            "description": "Enable safety content filtering",
            "default": true
          },
          "showExplicitContent": {
            "type": "boolean",
            "description": "Allow explicit content (inverse of safety checker)",
            "default": false
          },
          "enable_prompt_expansion": {
            "type": "boolean",
            "description": "Enable automatic prompt expansion"
          },
          "acceleration": {
            "type": "boolean",
            "description": "Enable acceleration for faster processing"
          },
          "shift": {
            "type": "number",
            "description": "Shift parameter for certain models"
          },
          "age_slider": {
            "type": "integer",
            "description": "Age setting for PromptChan model",
            "minimum": 18,
            "maximum": 60,
            "default": 18
          },
          "audioEnabled": {
            "type": "boolean",
            "description": "Enable audio for PromptChan model",
            "default": false
          },
          "video_quality": {
            "type": "string",
            "description": "Video quality for PromptChan model",
            "enum": ["Standard", "High"],
            "default": "Standard"
          },
          "aspect": {
            "type": "string",
            "description": "Aspect setting for PromptChan model",
            "enum": ["Portrait", "Landscape", "Square"],
            "default": "Portrait"
          }
        }
      },
      "VideoExtendRequest": {
        "type": "object",
        "required": ["taskId", "index"],
        "properties": {
          "taskId": {
            "type": "string",
            "description": "Run ID from the original Midjourney video request."
          },
          "index": {
            "type": "integer",
            "description": "Zero-based index of the Midjourney video to extend (0-3).",
            "minimum": 0,
            "maximum": 3
          }
        },
        "example": {
          "taskId": "fal-request-abc123xyz",
          "index": 0
        }
      },
      "VideoGenerationResponse": {
        "type": "object",
        "required": ["runId", "status", "model"],
        "properties": {
          "runId": {
            "type": "string",
            "description": "Unique identifier for the video generation request"
          },
          "projectId": {
            "type": "string",
            "description": "Project identifier (for LongStories models)"
          },
          "status": {
            "type": "string",
            "description": "Current status of the generation",
            "enum": ["pending", "processing", "completed", "failed"],
            "default": "pending"
          },
          "model": {
            "type": "string",
            "description": "The model used for generation"
          },
          "cost": {
            "type": "number",
            "description": "Cost of the video generation"
          },
          "paymentSource": {
            "type": "string",
            "description": "Payment source used (USD or XNO)"
          },
          "remainingBalance": {
            "type": "number",
            "description": "Remaining balance after the generation"
          },
          "prechargeLabel": {
            "type": "string",
            "description": "Provider label for the precharge"
          }
        }
      },
      "VideoStatusResponse": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "description": "Current status of the generation",
            "enum": ["PENDING", "PROCESSING", "COMPLETED", "FAILED"]
          },
          "data": {
            "type": "object",
            "properties": {
              "isCompleted": {
                "type": "boolean",
                "description": "Whether the generation is completed"
              },
              "isSuccess": {
                "type": "boolean",
                "description": "Whether the generation was successful"
              },
              "output": {
                "type": "object",
                "properties": {
                  "url": {
                    "type": "string",
                    "description": "URL to the generated video"
                  }
                }
              }
            }
          }
        }
      },
      "GenerateVideoStatusResponse": {
        "type": "object",
        "properties": {
          "data": {
            "type": "object",
            "properties": {
              "status": {
                "type": "string",
                "description": "Current status",
                "enum": ["IN_QUEUE", "IN_PROGRESS", "COMPLETED", "FAILED", "CANCELED"]
              },
              "request_id": {
                "type": "string",
                "description": "Provider request identifier"
              },
              "output": {
                "type": "object",
                "properties": {
                  "video": {
                    "type": "object",
                    "properties": {
                      "url": { "type": "string", "description": "Final video URL" }
                    }
                  }
                }
              },
              "cost": {
                "type": "number",
                "description": "Final cost for the video generation"
              },
              "error": {
                "type": "string",
                "nullable": true
              },
              "isNSFWError": {
                "type": "boolean",
                "nullable": true
              },
              "userFriendlyError": {
                "type": "string",
                "nullable": true
              }
            }
          }
        }
      },
      "CheckMidjourneyStatusRequest": {
        "type": "object",
        "required": ["task_id"],
        "properties": {
          "task_id": {
            "type": "string",
            "description": "The unique identifier for the Midjourney generation task.",
            "example": "1744449927914205"
          }
        }
      },
      "CheckMidjourneyStatusResponse": {
        "type": "object",
        "required": ["status", "task_id"],
        "properties": {
          "status": {
            "type": "string",
            "description": "The current status of the Midjourney task.",
            "enum": ["SUCCESS", "FAILED", "PENDING", "RUNNING", "IN_PROGRESS", "submitted", "NOT_START", "unknown"],
            "example": "SUCCESS"
          },
          "task_id": {
            "type": "string",
            "description": "The unique identifier for the Midjourney generation task.",
            "example": "1744449927914205"
          },
          "progress": {
            "type": "string",
            "description": "Optional progress indicator (e.g., \"0%\")",
            "example": "50%",
            "nullable": true
          },
          "imageUrl": {
            "type": "string",
            "format": "uri",
            "description": "The URL of the generated image (present on SUCCESS).",
            "example": "https://image-url.com/generated_image.png",
            "nullable": true
          },
          "failReason": {
            "type": "string",
            "description": "The reason for failure (present on FAILED).",
            "example": "Content moderation filter triggered.",
            "nullable": true
          }
        }
      },
      "OpenAIImageGenerationsRequest": {
        "type": "object",
        "required": [
          "prompt"
        ],
        "properties": {
          "model": {
            "type": "string",
            "description": "The model to use for generation",
            "default": "hidream"
          },
          "prompt": {
            "type": "string",
            "description": "The text prompt to generate an image from"
          },
          "n": {
            "type": "integer",
            "description": "Number of images to generate",
            "default": 1
          },
          "size": {
            "type": "string",
            "description": "The size of the generated images",
            "enum": ["256x256", "512x512", "1024x1024"]
          },
          "response_format": {
            "type": "string",
            "description": "The format in which the generated images are returned. Use \"b64_json\" (default) to receive base64-encoded image bytes in data[i].b64_json, or \"url\" to receive a time-limited, signed download URL in data[i].url (expires after a short period, currently ~1 hour). Note: When requesting \"url\", the API may still return \"b64_json\" if URL generation (upload/presign) fails, as a fallback.",
            "enum": ["url", "b64_json"],
            "default": "b64_json"
          },
          "user": {
            "type": "string",
            "description": "A unique identifier representing your end-user"
          },
          "imageDataUrl": {
            "type": "string",
            "description": "Base64-encoded image data URL for img2img generation. Single image input for models that support image-to-image transformation. Format: data:image/[type];base64,[data]. Note: Direct URL input is not supported - images must be converted to base64 data URLs before submission.",
            "example": "data:image/jpeg;base64,/9j/4AAQ..."
          },
          "imageDataUrls": {
            "type": "array",
            "description": "Array of base64-encoded image data URLs for models supporting multiple image inputs (e.g., flux-kontext, gpt-4o-image, gpt-image-1). Each URL must follow the format: data:image/[type];base64,[data]",
            "items": {
              "type": "string",
              "format": "data-url"
            },
            "example": [
              "data:image/jpeg;base64,/9j/4AAQ...",
              "data:image/png;base64,iVBORw0KGgo..."
            ]
          },
          "maskDataUrl": {
            "type": "string",
            "description": "Base64-encoded mask image data URL for inpainting models (e.g., flux-lora/inpainting). White areas indicate regions to edit. Format: data:image/[type];base64,[data]",
            "example": "data:image/png;base64,iVBORw0KGgo..."
          },
          "strength": {
            "type": "number",
            "description": "Controls how much the output differs from the input image in img2img mode. Lower values produce outputs closer to the input.",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.8
          },
          "guidance_scale": {
            "type": "number",
            "description": "How closely the model follows the text prompt. Higher values result in images more closely aligned with the prompt.",
            "minimum": 0.0,
            "maximum": 20.0,
            "default": 7.5
          },
          "num_inference_steps": {
            "type": "integer",
            "description": "Number of denoising steps. More steps generally produce higher quality but take longer.",
            "minimum": 1,
            "maximum": 100,
            "default": 30
          },
          "seed": {
            "type": "integer",
            "description": "Random seed for reproducible generation. Use the same seed with the same parameters to get identical results.",
            "example": 42
          },
          "kontext_max_mode": {
            "type": "boolean",
            "description": "Enable enhanced context mode for flux-kontext model. Provides better understanding of input images.",
            "default": false
          }
        }
      },
      "OpenAIImageGenerationsResponse": {
        "type": "object",
        "properties": {
          "created": {
            "type": "integer",
            "description": "Unix timestamp of when the image was created"
          },
          "data": {
            "type": "array",
            "description": "List of generated images. Each entry contains either a hosted URL (data[i].url) or base64-encoded bytes (data[i].b64_json), never both.",
            "items": {
              "oneOf": [
                {
                  "type": "object",
                  "required": ["url"],
                  "properties": {
                    "url": {
                      "type": "string",
                      "format": "uri",
                      "description": "Time-limited, signed download URL (presigned URL) to the generated image. It will expire after a short period (currently ~1 hour). If you need long-term access, download the image and store it yourself."
                    }
                  },
                  "additionalProperties": false,
                  "example": { "url": "https://...signed-url..." }
                },
                {
                  "type": "object",
                  "required": ["b64_json"],
                  "properties": {
                    "b64_json": { "type": "string", "description": "Base64 encoded image data" }
                  },
                  "additionalProperties": false,
                  "example": { "b64_json": "<base64-encoded-image-bytes>" }
                }
              ]
            }
          },
          "cost": {
            "type": "number",
            "description": "Cost of the generation"
          },
          "paymentSource": {
            "type": "string",
            "description": "Payment source used"
          },
          "remainingBalance": {
            "type": "number",
            "description": "Remaining balance after the generation"
          }
        }
      },
      "TEEAttestationResponse": {
        "type": "object",
        "properties": {
          "attestation": {
            "type": "string",
            "description": "The attestation report"
          }
        }
      },
      "TEESignatureResponse": {
        "type": "object",
        "properties": {
          "signature": {
            "type": "string",
            "description": "The ECDSA signature"
          }
        }
      },
      "UnifiedVideoStatusResponse": {
        "type": "object",
        "required": [
          "requestId",
          "status",
          "videoUrl",
          "error",
          "createdAt",
          "completedAt"
        ],
        "properties": {
          "requestId": {
            "type": "string",
            "description": "The unique request ID for the video generation"
          },
          "status": {
            "type": "string",
            "description": "Current normalized status of the video generation",
            "enum": ["queued", "processing", "completed", "failed", "cancelled", "unknown"]
          },
          "progress": {
            "type": "number",
            "nullable": true,
            "description": "Generation progress as a percentage (0-100), if available"
          },
          "estimatedTimeRemaining": {
            "type": "number",
            "nullable": true,
            "description": "Estimated time remaining in seconds, if available"
          },
          "videoUrl": {
            "type": "string",
            "nullable": true,
            "description": "URL to the generated video (available when status is 'completed')"
          },
          "error": {
            "type": "string",
            "nullable": true,
            "description": "Error message if the generation failed"
          },
          "createdAt": {
            "type": "string",
            "nullable": true,
            "description": "ISO timestamp when the request was created"
          },
          "completedAt": {
            "type": "string",
            "nullable": true,
            "description": "ISO timestamp when the generation completed"
          }
        }
      },
      "TranscribeFormRequest": {
        "type": "object",
        "properties": {
          "audio": {
            "type": "string",
            "format": "binary",
            "description": "Direct file upload (max 3MB). Supported formats: MP3, WAV, M4A, OGG, AAC"
          },
          "audioUrl": {
            "type": "string",
            "format": "uri",
            "description": "URL to audio file (alternative to direct upload, supports up to 500MB)"
          },
          "model": {
            "type": "string",
            "description": "The STT model to use for transcription",
            "enum": ["Whisper-Large-V3", "Wizper", "Elevenlabs-STT"],
            "default": "Whisper-Large-V3"
          },
          "language": {
            "type": "string",
            "description": "Language code for transcription (ISO 639-1 or ISO 639-3). Use 'auto' for auto-detection",
            "default": "auto",
            "example": "en"
          },
          "actualDuration": {
            "type": "string",
            "description": "Actual audio duration in minutes for accurate billing"
          },
          "diarize": {
            "type": "string",
            "description": "Enable speaker diarization (Elevenlabs-STT only)",
            "enum": ["true", "false"],
            "default": "false"
          },
          "tagAudioEvents": {
            "type": "string",
            "description": "Tag non-speech audio events like [laughter], [applause] (Elevenlabs-STT only)",
            "enum": ["true", "false"],
            "default": "false"
          }
        }
      },
      "TranscribeJsonRequest": {
        "type": "object",
        "properties": {
          "audioUrl": {
            "type": "string",
            "format": "uri",
            "description": "URL to audio file to transcribe",
            "example": "https://example.com/audio.mp3"
          },
          "model": {
            "type": "string",
            "description": "The STT model to use for transcription",
            "enum": ["Whisper-Large-V3", "Wizper", "Elevenlabs-STT"],
            "default": "Whisper-Large-V3"
          },
          "language": {
            "type": "string",
            "description": "Language code for transcription (ISO 639-1 or ISO 639-3). Use 'auto' for auto-detection",
            "default": "auto",
            "example": "en"
          },
          "actualDuration": {
            "type": "string",
            "description": "Actual audio duration in minutes for accurate billing"
          },
          "diarize": {
            "type": "boolean",
            "description": "Enable speaker diarization (Elevenlabs-STT only)",
            "default": false
          },
          "tagAudioEvents": {
            "type": "boolean",
            "description": "Tag non-speech audio events like [laughter], [applause] (Elevenlabs-STT only)",
            "default": false
          }
        },
        "required": ["audioUrl"]
      },
      "TranscribeResponse": {
        "type": "object",
        "required": ["transcription", "metadata"],
        "properties": {
          "transcription": {
            "type": "string",
            "description": "The transcribed text",
            "example": "Hello, this is a test transcription."
          },
          "metadata": {
            "type": "object",
            "required": ["model", "cost", "currency"],
            "properties": {
              "fileName": {
                "type": "string",
                "description": "Original file name"
              },
              "fileSize": {
                "type": "integer",
                "description": "File size in bytes"
              },
              "chargedDuration": {
                "type": "number",
                "description": "Duration charged for billing (in minutes)"
              },
              "actualDuration": {
                "type": "number",
                "description": "Actual audio duration (in minutes)"
              },
              "language": {
                "type": "string",
                "description": "Detected or specified language code"
              },
              "cost": {
                "type": "number",
                "description": "Cost of the transcription"
              },
              "currency": {
                "type": "string",
                "description": "Currency of the cost",
                "default": "USD"
              },
              "model": {
                "type": "string",
                "description": "Model used for transcription"
              }
            }
          }
        }
      },
      "TranscribeAsyncResponse": {
        "type": "object",
        "required": ["runId", "status", "model"],
        "properties": {
          "runId": {
            "type": "string",
            "description": "Unique identifier for the transcription job",
            "example": "abc123def456"
          },
          "status": {
            "type": "string",
            "description": "Current status of the transcription job",
            "enum": ["pending", "processing", "completed", "failed"],
            "default": "pending"
          },
          "model": {
            "type": "string",
            "description": "Model used for transcription"
          },
          "cost": {
            "type": "number",
            "description": "Cost of the transcription"
          },
          "paymentSource": {
            "type": "string",
            "description": "Payment source used (USD or XNO)"
          },
          "isApiRequest": {
            "type": "boolean",
            "description": "Whether this is an API request"
          },
          "fileName": {
            "type": "string",
            "description": "Original file name"
          },
          "fileSize": {
            "type": "integer",
            "description": "File size in bytes"
          },
          "chargedDuration": {
            "type": "number",
            "description": "Duration charged for billing (in minutes)"
          },
          "diarize": {
            "type": "boolean",
            "description": "Whether speaker diarization is enabled"
          }
        }
      },
      "TranscribeStatusRequest": {
        "type": "object",
        "required": ["runId"],
        "properties": {
          "runId": {
            "type": "string",
            "description": "Unique identifier for the transcription job",
            "example": "abc123def456"
          },
          "cost": {
            "type": "number",
            "description": "Cost of the transcription (from initial response)"
          },
          "paymentSource": {
            "type": "string",
            "description": "Payment source used (from initial response)"
          },
          "isApiRequest": {
            "type": "boolean",
            "description": "Whether this is an API request (from initial response)"
          },
          "fileName": {
            "type": "string",
            "description": "Original file name (from initial response)"
          },
          "fileSize": {
            "type": "integer",
            "description": "File size in bytes (from initial response)"
          },
          "chargedDuration": {
            "type": "number",
            "description": "Duration charged for billing (from initial response)"
          },
          "diarize": {
            "type": "boolean",
            "description": "Whether speaker diarization is enabled (from initial response)"
          }
        }
      },
      "TranscribeStatusResponse": {
        "type": "object",
        "required": ["status"],
        "properties": {
          "status": {
            "type": "string",
            "description": "Current status of the transcription job",
            "enum": ["pending", "processing", "completed", "failed"]
          },
          "transcription": {
            "type": "string",
            "description": "The transcribed text (available when status is 'completed')",
            "example": "Speaker 1: Hello everyone. Speaker 2: Hi there!"
          },
          "metadata": {
            "type": "object",
            "description": "Transcription metadata (available when status is 'completed')",
            "properties": {
              "fileName": {
                "type": "string",
                "description": "Original file name"
              },
              "fileSize": {
                "type": "integer",
                "description": "File size in bytes"
              },
              "chargedDuration": {
                "type": "number",
                "description": "Duration charged for billing (in minutes)"
              },
              "actualDuration": {
                "type": "number",
                "description": "Actual audio duration (in minutes)"
              },
              "language": {
                "type": "string",
                "description": "Detected language code"
              },
              "cost": {
                "type": "number",
                "description": "Cost of the transcription"
              },
              "currency": {
                "type": "string",
                "description": "Currency of the cost"
              },
              "model": {
                "type": "string",
                "description": "Model used for transcription"
              }
            }
          },
          "words": {
            "type": "array",
            "description": "Word-level timestamps and speaker information (Elevenlabs-STT only)",
            "items": {
              "type": "object",
              "properties": {
                "text": {
                  "type": "string",
                  "description": "The word or text segment"
                },
                "start": {
                  "type": "number",
                  "description": "Start time in seconds"
                },
                "end": {
                  "type": "number",
                  "description": "End time in seconds"
                },
                "type": {
                  "type": "string",
                  "description": "Type of segment",
                  "enum": ["word", "punctuation"]
                },
                "speaker_id": {
                  "type": "string",
                  "description": "Speaker identifier (when diarization is enabled)"
                }
              }
            }
          },
          "diarization": {
            "type": "object",
            "description": "Speaker diarization results (when enabled)",
            "properties": {
              "segments": {
                "type": "array",
                "description": "Speaker segments with timestamps",
                "items": {
                  "type": "object",
                  "properties": {
                    "speaker": {
                      "type": "string",
                      "description": "Speaker label (e.g., 'Speaker 1')"
                    },
                    "text": {
                      "type": "string",
                      "description": "Text spoken by this speaker"
                    },
                    "start": {
                      "type": "number",
                      "description": "Start time in seconds"
                    },
                    "end": {
                      "type": "number",
                      "description": "End time in seconds"
                    }
                  }
                }
              }
            }
          },
          "error": {
            "type": "string",
            "description": "Error message (available when status is 'failed')"
          }
        }
      },
      "TTSRequest": {
        "type": "object",
        "required": ["text"],
        "properties": {
          "text": {
            "type": "string",
            "description": "The text to convert to speech",
            "example": "Hello! This is a test of the text-to-speech API."
          },
          "model": {
            "type": "string",
            "description": "The TTS model to use for generation",
            "enum": ["Kokoro-82m", "Elevenlabs-Turbo-V2.5", "tts-1", "tts-1-hd", "gpt-4o-mini-tts"],
            "default": "Kokoro-82m"
          },
          "voice": {
            "type": "string",
            "description": "The voice to use for synthesis (available voices depend on selected model)",
            "example": "af_bella"
          },
          "speed": {
            "type": "number",
            "description": "Speech speed multiplier (0.1-5, not supported for gpt-4o-mini-tts)",
            "minimum": 0.1,
            "maximum": 5,
            "default": 1
          },
          "response_format": {
            "type": "string",
            "description": "Audio output format (OpenAI models only)",
            "enum": ["mp3", "opus", "aac", "flac", "wav", "pcm"],
            "default": "mp3"
          },
          "instructions": {
            "type": "string",
            "description": "Voice instructions for fine-tuning (gpt-4o-mini-tts and tts-1-hd only)",
            "example": "speak with enthusiasm"
          },
          "stability": {
            "type": "number",
            "description": "Voice stability (Elevenlabs-Turbo-V2.5 only, 0-1)",
            "minimum": 0,
            "maximum": 1,
            "default": 0.5
          },
          "similarity_boost": {
            "type": "number",
            "description": "Voice similarity boost (Elevenlabs-Turbo-V2.5 only, 0-1)",
            "minimum": 0,
            "maximum": 1,
            "default": 0.75
          },
          "style": {
            "type": "number",
            "description": "Style exaggeration (Elevenlabs-Turbo-V2.5 only, 0-1)",
            "minimum": 0,
            "maximum": 1,
            "default": 0
          }
        }
      },
      "TTSResponse": {
        "type": "object",
        "properties": {
          "audioUrl": {
            "type": "string",
            "format": "uri",
            "description": "URL to the generated audio file",
            "example": "https://storage.url/audio-file.wav"
          },
          "contentType": {
            "type": "string",
            "description": "MIME type of the audio file",
            "example": "audio/wav"
          },
          "model": {
            "type": "string",
            "description": "Model used for generation"
          },
          "text": {
            "type": "string",
            "description": "The input text that was synthesized"
          },
          "voice": {
            "type": "string",
            "description": "Voice used for synthesis"
          },
          "speed": {
            "type": "number",
            "description": "Speed multiplier used"
          },
          "duration": {
            "type": "number",
            "description": "Duration of the generated audio in seconds"
          },
          "cost": {
            "type": "number",
            "description": "Cost of the generation"
          },
          "currency": {
            "type": "string",
            "description": "Currency of the cost"
          }
        }
      },
      "YouTubeTranscribeRequest": {
        "type": "object",
        "required": ["urls"],
        "properties": {
          "urls": {
            "type": "array",
            "description": "Array of YouTube URLs to transcribe (maximum 10 URLs per request)",
            "items": {
              "type": "string",
              "format": "uri",
              "description": "YouTube URL in supported format"
            },
            "minItems": 1,
            "maxItems": 10,
            "example": [
              "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
              "https://youtu.be/kJQP7kiw5Fk"
            ]
          }
        }
      },
      "YouTubeTranscribeResponse": {
        "type": "object",
        "required": ["transcripts", "summary"],
        "properties": {
          "transcripts": {
            "type": "array",
            "description": "Array of transcript results for each URL",
            "items": {
              "type": "object",
              "required": ["url", "success"],
              "properties": {
                "url": {
                  "type": "string",
                  "description": "The original YouTube URL"
                },
                "success": {
                  "type": "boolean",
                  "description": "Whether the transcript was successfully retrieved"
                },
                "title": {
                  "type": "string",
                  "description": "Video title (only if successful)"
                },
                "transcript": {
                  "type": "string",
                  "description": "The full transcript text (only if successful)"
                },
                "error": {
                  "type": "string",
                  "description": "Error message (only if failed)"
                }
              }
            }
          },
          "summary": {
            "type": "object",
            "required": ["requested", "processed", "successful", "failed", "totalCost"],
            "properties": {
              "requested": {
                "type": "integer",
                "description": "Number of URLs provided in the request"
              },
              "processed": {
                "type": "integer",
                "description": "Number of valid YouTube URLs found and processed"
              },
              "successful": {
                "type": "integer",
                "description": "Number of transcripts successfully retrieved"
              },
              "failed": {
                "type": "integer",
                "description": "Number of transcripts that failed"
              },
              "totalCost": {
                "type": "number",
                "description": "Total cost in USD for successful transcripts"
              }
            }
          }
        }
      },
      "ScrapeUrlsRequest": {
        "type": "object",
        "required": ["urls"],
        "properties": {
          "urls": {
            "type": "array",
            "description": "Array of URLs to scrape (maximum 5 URLs per request)",
            "items": {
              "type": "string",
              "format": "uri",
              "description": "URL to scrape"
            },
            "minItems": 1,
            "maxItems": 5,
            "example": [
              "https://example.com/article",
              "https://blog.com/post"
            ]
          }
        }
      },
      "ScrapeUrlsResponse": {
        "type": "object",
        "required": ["results", "summary"],
        "properties": {
          "results": {
            "type": "array",
            "description": "Array of scraping results for each URL",
            "items": {
              "type": "object",
              "required": ["url", "success"],
              "properties": {
                "url": {
                  "type": "string",
                  "description": "The URL that was scraped"
                },
                "success": {
                  "type": "boolean",
                  "description": "Whether the scraping was successful"
                },
                "title": {
                  "type": "string",
                  "description": "Page title if successfully scraped"
                },
                "content": {
                  "type": "string",
                  "description": "Raw HTML content"
                },
                "markdown": {
                  "type": "string",
                  "description": "Formatted markdown version of the content"
                },
                "error": {
                  "type": "string",
                  "description": "Error message if scraping failed"
                }
              }
            }
          },
          "summary": {
            "type": "object",
            "required": ["requested", "processed", "successful", "failed", "totalCost"],
            "properties": {
              "requested": {
                "type": "number",
                "description": "Number of URLs in the original request"
              },
              "processed": {
                "type": "number",
                "description": "Number of valid URLs that were processed"
              },
              "successful": {
                "type": "number",
                "description": "Number of URLs successfully scraped"
              },
              "failed": {
                "type": "number",
                "description": "Number of URLs that failed to scrape"
              },
              "totalCost": {
                "type": "number",
                "description": "Total cost in USD (only for successful scrapes)"
              }
            }
          }
        }
      },
      "WebSearchRequest": {
        "type": "object",
        "required": ["query"],
        "properties": {
          "query": {
            "type": "string",
            "description": "The search query to send to Linkup",
            "example": "latest AI news"
          },
          "depth": {
            "type": "string",
            "description": "Search depth. Standard ($0.006) or deep ($0.06)",
            "enum": ["standard", "deep"],
            "default": "standard"
          },
          "outputType": {
            "type": "string",
            "description": "Output format for search results",
            "enum": ["searchResults", "sourcedAnswer", "structured"],
            "default": "searchResults"
          },
          "structuredOutputSchema": {
            "type": "string",
            "description": "JSON schema string defining the desired response format. Required when outputType is 'structured'",
            "example": "{\"type\": \"object\", \"properties\": {\"items\": {\"type\": \"array\"}}}"
          },
          "includeImages": {
            "type": "boolean",
            "description": "Whether to include image results in the search",
            "default": false
          },
          "fromDate": {
            "type": "string",
            "description": "Filter results from this date (YYYY-MM-DD format)",
            "example": "2025-01-01"
          },
          "toDate": {
            "type": "string",
            "description": "Filter results until this date (YYYY-MM-DD format)",
            "example": "2025-07-01"
          },
          "excludeDomains": {
            "type": "array",
            "description": "Array of domains to exclude from search results",
            "items": {
              "type": "string"
            },
            "example": ["example.com", "spam.com"]
          },
          "includeDomains": {
            "type": "array",
            "description": "Array of domains to search exclusively",
            "items": {
              "type": "string"
            },
            "example": ["trusted.com", "official.org"]
          }
        }
      },
      "WebSearchResponse": {
        "type": "object",
        "required": ["data", "metadata"],
        "properties": {
          "data": {
            "oneOf": [
              {
                "type": "array",
                "description": "Array of search results when outputType is 'searchResults'",
                "items": {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": ["text", "image"],
                      "description": "Type of search result"
                    },
                    "title": {
                      "type": "string",
                      "description": "Title of the result"
                    },
                    "url": {
                      "type": "string",
                      "description": "URL of the result"
                    },
                    "content": {
                      "type": "string",
                      "description": "Content snippet (for text results)"
                    },
                    "imageUrl": {
                      "type": "string",
                      "description": "Image URL (for image results)"
                    }
                  }
                }
              },
              {
                "type": "object",
                "description": "Sourced answer when outputType is 'sourcedAnswer'",
                "properties": {
                  "answer": {
                    "type": "string",
                    "description": "The comprehensive answer to the query"
                  },
                  "sources": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "name": {
                          "type": "string",
                          "description": "Source name"
                        },
                        "url": {
                          "type": "string",
                          "description": "Source URL"
                        },
                        "snippet": {
                          "type": "string",
                          "description": "Relevant snippet from the source"
                        }
                      }
                    }
                  }
                }
              },
              {
                "type": "object",
                "description": "Structured data matching the provided schema"
              }
            ]
          },
          "metadata": {
            "type": "object",
            "required": ["query", "depth", "outputType", "timestamp", "cost"],
            "properties": {
              "query": {
                "type": "string",
                "description": "The search query that was executed"
              },
              "depth": {
                "type": "string",
                "description": "The search depth used",
                "enum": ["standard", "deep"]
              },
              "outputType": {
                "type": "string",
                "description": "The output format used",
                "enum": ["searchResults", "sourcedAnswer", "structured"]
              },
              "timestamp": {
                "type": "string",
                "description": "ISO 8601 timestamp of when the search was performed"
              },
              "cost": {
                "type": "number",
                "description": "The cost of the search in USD"
              }
            }
          }
        }
      },
      "CryptoDepositRequest": {
        "type": "object",
        "required": ["amount"],
        "properties": {
          "amount": {
            "type": "number",
            "description": "Amount of cryptocurrency to deposit. Must be between minimum and maximum limits based on USD equivalent (default $1-$2,000, varies by currency).",
            "example": 0.001
          }
        }
      },
      "CryptoDepositResponse": {
        "type": "object",
        "required": ["txId", "amount", "status", "address"],
        "properties": {
          "txId": {
            "type": "string",
            "description": "Unique transaction identifier",
            "example": "abc123"
          },
          "address": {
            "type": "string",
            "description": "Deposit address for sending crypto",
            "example": "bc1q..."
          },
          "amount": {
            "type": "number",
            "description": "Requested deposit amount",
            "example": 0.001
          },
          "status": {
            "type": "string",
            "description": "Payment status",
            "enum": ["New", "Pending", "Processing", "Completed"],
            "example": "New"
          },
          "paymentLink": {
            "type": "string",
            "description": "URI for wallet apps (e.g., bitcoin:address)",
            "example": "bitcoin:bc1q...?amount=0.001"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "ISO timestamp of creation",
            "example": "2026-01-19T12:00:00.000Z"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "ISO timestamp when address expires",
            "example": "2026-01-19T13:00:00.000Z"
          }
        }
      },
      "CryptoLimitsResponse": {
        "type": "object",
        "required": ["minimum", "maximum", "fiatEquivalentMinimum", "fiatEquivalentMaximum", "timestamp"],
        "properties": {
          "minimum": {
            "type": "number",
            "description": "Minimum deposit amount in cryptocurrency",
            "example": 10.5
          },
          "maximum": {
            "type": "number",
            "description": "Maximum deposit amount in cryptocurrency",
            "example": 5250
          },
          "fiatEquivalentMinimum": {
            "type": "number",
            "description": "Minimum deposit amount in USD equivalent",
            "example": 1
          },
          "fiatEquivalentMaximum": {
            "type": "number",
            "description": "Maximum deposit amount in USD equivalent",
            "example": 500
          },
          "timestamp": {
            "type": "integer",
            "description": "Unix timestamp of when limits were retrieved",
            "example": 1705669200
          }
        }
      },
      "EmbeddingRequest": {
        "type": "object",
        "required": ["input", "model"],
        "properties": {
          "input": {
            "oneOf": [
              {
                "type": "string",
                "description": "Single text string to embed"
              },
              {
                "type": "array",
                "description": "Array of text strings to embed (max 2048)",
                "items": {
                  "type": "string"
                },
                "maxItems": 2048
              }
            ],
            "description": "Text to embed - single string or array of up to 2048 strings"
          },
          "model": {
            "type": "string",
            "description": "ID of the embedding model to use",
            "example": "text-embedding-3-small"
          },
          "encoding_format": {
            "type": "string",
            "description": "Format for embeddings",
            "enum": ["float", "base64"],
            "default": "float"
          },
          "dimensions": {
            "type": "integer",
            "description": "Reduce embedding dimensions (only for supported models)",
            "example": 256
          },
          "user": {
            "type": "string",
            "description": "Optional identifier for tracking usage"
          }
        }
      },
      "EmbeddingResponse": {
        "type": "object",
        "required": ["object", "data", "model", "usage"],
        "properties": {
          "object": {
            "type": "string",
            "description": "Always 'list' for embeddings",
            "example": "list"
          },
          "data": {
            "type": "array",
            "description": "Array of embedding objects",
            "items": {
              "type": "object",
              "required": ["object", "index", "embedding"],
              "properties": {
                "object": {
                  "type": "string",
                  "description": "Always 'embedding'",
                  "example": "embedding"
                },
                "index": {
                  "type": "integer",
                  "description": "Index of this embedding in the batch",
                  "example": 0
                },
                "embedding": {
                  "oneOf": [
                    {
                      "type": "array",
                      "description": "Embedding vector as array of floats",
                      "items": {
                        "type": "number"
                      }
                    },
                    {
                      "type": "string",
                      "description": "Base64-encoded embedding vector"
                    }
                  ]
                }
              }
            }
          },
          "model": {
            "type": "string",
            "description": "Model used for embeddings",
            "example": "text-embedding-3-small"
          },
          "usage": {
            "type": "object",
            "required": ["prompt_tokens", "total_tokens"],
            "properties": {
              "prompt_tokens": {
                "type": "integer",
                "description": "Number of tokens in the input",
                "example": 8
              },
              "total_tokens": {
                "type": "integer",
                "description": "Total tokens processed",
                "example": 8
              }
            }
          }
        }
      },
      "EmbeddingModelsResponse": {
        "type": "object",
        "required": ["object", "data"],
        "properties": {
          "object": {
            "type": "string",
            "description": "Always 'list'",
            "example": "list"
          },
          "data": {
            "type": "array",
            "description": "Array of embedding model objects",
            "items": {
              "type": "object",
              "required": ["id", "object", "created", "owned_by"],
              "properties": {
                "id": {
                  "type": "string",
                  "description": "Unique model identifier",
                  "example": "text-embedding-3-small"
                },
                "object": {
                  "type": "string",
                  "description": "Always 'model'",
                  "example": "model"
                },
                "created": {
                  "type": "integer",
                  "description": "Unix timestamp",
                  "example": 1754480583
                },
                "owned_by": {
                  "type": "string",
                  "description": "Model provider",
                  "example": "openai"
                },
                "name": {
                  "type": "string",
                  "description": "Human-readable model name",
                  "example": "Text Embedding 3 Small"
                },
                "description": {
                  "type": "string",
                  "description": "Model description and use cases",
                  "example": "Most cost-effective OpenAI embedding model with dimension reduction support"
                },
                "dimensions": {
                  "type": "integer",
                  "description": "Default embedding vector dimensions",
                  "example": 1536
                },
                "supports_dimensions": {
                  "type": "boolean",
                  "description": "Whether model supports dimension reduction",
                  "example": true
                },
                "max_tokens": {
                  "type": "integer",
                  "description": "Maximum input tokens supported",
                  "example": 8191
                },
                "pricing": {
                  "type": "object",
                  "required": ["per_million_tokens", "currency"],
                  "properties": {
                    "per_million_tokens": {
                      "type": "number",
                      "description": "Cost per million tokens",
                      "example": 0.02
                    },
                    "currency": {
                      "type": "string",
                      "description": "Pricing currency",
                      "example": "USD"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "MemoryRequest": {
        "type": "object",
        "required": ["messages"],
        "properties": {
          "messages": {
            "type": "array",
            "description": "OpenAI-style messages array to compress",
            "items": {
              "type": "object",
              "properties": {
                "role": { "type": "string", "enum": ["system", "user", "assistant", "tool", "function"] },
                "content": { "oneOf": [ { "type": "string" }, { "type": "array" } ] }
              },
              "required": ["role", "content"]
            }
          },
          "expiration_days": {
            "type": "integer",
            "description": "Retention in days (1..365). Defaults to 30 if not provided.",
            "minimum": 1,
            "maximum": 365,
            "default": 30
          },
          "model_context_limit": {
            "type": "integer",
            "description": "Target context size for compression (minimum enforced 10,000)",
            "default": 128000
          }
        }
      },
      "MemoryResponse": {
        "type": "object",
        "required": ["messages", "usage"],
        "properties": {
          "messages": {
            "type": "array",
            "description": "Compressed memory message array",
            "items": {
              "type": "object",
              "properties": {
                "role": { "type": "string" },
                "content": { "type": "string" }
              },
              "required": ["role", "content"]
            }
          },
          "usage": {
            "type": "object",
            "properties": {
              "prompt_tokens": { "type": "integer" },
              "completion_tokens": { "type": "integer" },
              "total_tokens": { "type": "integer" },
              "prompt_tokens_details": {
                "type": "object",
                "properties": {
                  "cached_tokens": { "type": "integer" }
                }
              }
            }
          }
        }
      },
      "ProviderPricing": {
        "type": "object",
        "required": ["inputPer1kTokens", "outputPer1kTokens"],
        "properties": {
          "inputPer1kTokens": {
            "type": "number",
            "description": "Price per 1K input tokens in USD",
            "example": 0.0004
          },
          "outputPer1kTokens": {
            "type": "number",
            "description": "Price per 1K output tokens in USD",
            "example": 0.00175
          }
        }
      },
      "ModelProviderEntry": {
        "type": "object",
        "required": ["provider", "pricing", "available"],
        "properties": {
          "provider": {
            "type": "string",
            "description": "Provider identifier",
            "example": "provider-id"
          },
          "pricing": {
            "$ref": "#/components/schemas/ProviderPricing"
          },
          "available": {
            "type": "boolean",
            "description": "Whether the provider is currently available",
            "example": true
          }
        }
      },
      "ModelProvidersResponse": {
        "type": "object",
        "properties": {
          "canonicalId": {
            "type": "string",
            "description": "Canonical model identifier",
            "example": "model-id"
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable model name",
            "example": "Model Name"
          },
          "supportsProviderSelection": {
            "type": "boolean",
            "description": "Whether the model supports provider selection",
            "example": true
          },
          "defaultPrice": {
            "$ref": "#/components/schemas/ProviderPricing"
          },
          "providers": {
            "type": "array",
            "description": "Available providers for the model",
            "items": {
              "$ref": "#/components/schemas/ModelProviderEntry"
            }
          }
        }
      },
      "ProviderPreferenceRule": {
        "type": "object",
        "properties": {
          "preferredProviders": {
            "type": "array",
            "description": "Ordered list of preferred providers",
            "items": {
              "type": "string"
            }
          },
          "excludedProviders": {
            "type": "array",
            "description": "Providers that should never be used",
            "items": {
              "type": "string"
            }
          },
          "enableFallback": {
            "type": "boolean",
            "description": "Whether to fall back to the platform default if no preferred provider is available",
            "default": true
          }
        }
      },
      "ProviderPreferencesResponse": {
        "type": "object",
        "properties": {
          "preferredProviders": {
            "type": "array",
            "description": "Ordered list of preferred providers",
            "items": {
              "type": "string"
            }
          },
          "excludedProviders": {
            "type": "array",
            "description": "Providers that should never be used",
            "items": {
              "type": "string"
            }
          },
          "enableFallback": {
            "type": "boolean",
            "description": "Whether to fall back to the platform default if no preferred provider is available",
            "default": true
          },
          "modelOverrides": {
            "type": "object",
            "description": "Per-model overrides for provider selection preferences",
            "additionalProperties": {
              "$ref": "#/components/schemas/ProviderPreferenceRule"
            }
          },
          "availableProviders": {
            "type": "array",
            "description": "Provider IDs available to the current user for the model",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ProviderPreferencesUpdateRequest": {
        "type": "object",
        "properties": {
          "preferredProviders": {
            "type": "array",
            "description": "Ordered list of preferred providers",
            "items": {
              "type": "string"
            }
          },
          "excludedProviders": {
            "type": "array",
            "description": "Providers that should never be used",
            "items": {
              "type": "string"
            }
          },
          "enableFallback": {
            "type": "boolean",
            "description": "Whether to fall back to the platform default if no preferred provider is available"
          },
          "modelOverrides": {
            "type": "object",
            "description": "Per-model overrides for provider selection preferences",
            "additionalProperties": {
              "$ref": "#/components/schemas/ProviderPreferenceRule"
            }
          }
        }
      },
      "ResponsesCreateRequest": {
        "type": "object",
        "required": ["model", "input"],
        "properties": {
          "model": {
            "type": "string",
            "description": "Model ID to use for the response"
          },
          "input": {
            "description": "Prompt string or array of input items",
            "oneOf": [
              { "type": "string" },
              {
                "type": "array",
                "items": { "type": "object", "additionalProperties": true }
              }
            ]
          },
          "instructions": {
            "type": "string",
            "description": "System instructions for the model"
          },
          "max_output_tokens": {
            "type": "integer",
            "minimum": 16,
            "description": "Maximum tokens in the response"
          },
          "temperature": {
            "type": "number",
            "minimum": 0,
            "maximum": 2,
            "description": "Sampling temperature (not supported by reasoning models)"
          },
          "top_p": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "description": "Nucleus sampling parameter"
          },
          "tools": {
            "type": "array",
            "description": "Function tools available to the model",
            "items": { "type": "object", "additionalProperties": true }
          },
          "tool_choice": {
            "description": "How the model should use tools",
            "oneOf": [
              { "type": "string" },
              { "type": "object", "additionalProperties": true }
            ]
          },
          "parallel_tool_calls": {
            "type": "boolean",
            "description": "Allow multiple tool calls in parallel"
          },
          "stream": {
            "type": "boolean",
            "description": "Enable streaming responses",
            "default": false
          },
          "store": {
            "type": "boolean",
            "description": "Store response for later retrieval",
            "default": true
          },
          "previous_response_id": {
            "type": "string",
            "description": "Link to previous response for conversation threading"
          },
          "reasoning": {
            "type": "object",
            "description": "Reasoning configuration for reasoning-capable models",
            "additionalProperties": true
          },
          "text": {
            "type": "object",
            "description": "Text/format configuration",
            "additionalProperties": true
          },
          "metadata": {
            "type": "object",
            "description": "Custom metadata",
            "additionalProperties": true
          },
          "truncation": {
            "type": "string",
            "enum": ["auto", "disabled"],
            "description": "Truncation strategy"
          },
          "user": {
            "type": "string",
            "description": "Unique user identifier"
          },
          "seed": {
            "type": "integer",
            "description": "Random seed for reproducibility"
          },
          "background": {
            "type": "boolean",
            "description": "Enable background/async processing"
          },
          "service_tier": {
            "type": "string",
            "enum": ["auto", "default", "flex", "priority"],
            "description": "Optional service tier. Set to \"priority\" to request priority processing when supported by the routed provider"
          }
        }
      },
      "ResponsesInfoResponse": {
        "type": "object",
        "description": "Endpoint information for the Responses API",
        "additionalProperties": true
      },
      "ResponsesResponse": {
        "type": "object",
        "description": "Response object returned by the Responses API",
        "additionalProperties": true,
        "properties": {
          "id": { "type": "string" },
          "object": { "type": "string" },
          "created_at": { "type": "integer" },
          "model": { "type": "string" },
          "status": {
            "type": "string",
            "enum": ["queued", "in_progress", "completed", "incomplete", "failed", "cancelled"]
          },
          "output": {
            "type": "array",
            "items": { "type": "object", "additionalProperties": true }
          },
          "output_text": { "type": "string" },
          "usage": { "type": "object", "additionalProperties": true },
          "error": { "type": "object", "additionalProperties": true },
          "incomplete_details": { "type": "object", "additionalProperties": true },
          "metadata": { "type": "object", "additionalProperties": true },
          "service_tier": { "type": "string" }
        }
      },
      "ResponsesDeleteResponse": {
        "type": "object",
        "required": ["id", "object", "deleted"],
        "properties": {
          "id": { "type": "string" },
          "object": { "type": "string", "example": "response.deleted" },
          "deleted": { "type": "boolean" }
        }
      },
      "InvitationCreateRequest": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "Either \"invitation\" or \"referralLink\". Defaults to \"invitation\".",
            "enum": ["invitation", "referralLink"]
          },
          "amount": {
            "type": "number",
            "description": "Credit amount to include with the invitation. Must be non-negative. Ignored for referral links (always 0).",
            "minimum": 0
          },
          "currency": {
            "type": "string",
            "description": "Currency for the amount. Required if amount > 0."
          },
          "recipientName": {
            "type": "string",
            "description": "Name of the invitation recipient."
          },
          "issuerName": {
            "type": "string",
            "description": "Name of the person sending the invitation."
          },
          "issuerNote": {
            "type": "string",
            "description": "Personal note to include with the invitation."
          }
        }
      },
      "InvitationCreateResponse": {
        "type": "object",
        "required": ["insertId", "redeemCode", "url", "type", "amount", "currency"],
        "properties": {
          "insertId": {
            "type": "string",
            "description": "Database ID of the created invitation."
          },
          "redeemCode": {
            "type": "string",
            "description": "Unique code the recipient uses to redeem the invitation."
          },
          "url": {
            "type": "string",
            "format": "uri",
            "description": "Full URL to share with the recipient."
          },
          "type": {
            "type": "string",
            "description": "The invitation type.",
            "enum": ["invitation", "referralLink"]
          },
          "amount": {
            "type": "number",
            "description": "Credit amount attached to this invitation."
          },
          "currency": {
            "type": ["string", "null"],
            "description": "Currency of the amount, or null if amount is 0."
          }
        }
      }
    },
    "securitySchemes": {
      "bearerAuth": {
        "type": "http",
        "scheme": "bearer"
      },
      "apiKeyAuth": {
        "type": "apiKey",
        "in": "header",
        "name": "x-api-key"
      }
    }
  }
}
